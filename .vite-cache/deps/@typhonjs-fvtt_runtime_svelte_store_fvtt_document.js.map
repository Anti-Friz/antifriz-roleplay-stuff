{
  "version": 3,
  "sources": ["../../../../../../program/Javascript/projects/TyphonJS/typhonjs-svelte/runtime-base/_dist/svelte/store/reducer/index.js", "../../../../../../program/Javascript/projects/TyphonJS/typhonjs-fvtt-lib/types-fvtt-shim/dist/guard/index.js", "../../../../../../program/Javascript/projects/TyphonJS/typhonjs-fvtt-lib/svelte/_dist/store/fvtt/document/index.js"],
  "sourcesContent": ["import { writable, get } from 'svelte/store';\nimport { isMinimalWritableStore } from '@typhonjs-svelte/runtime-base/svelte/store/util';\nimport { Strings } from '@typhonjs-svelte/runtime-base/util';\nimport { isIterable, safeAccess } from '@typhonjs-svelte/runtime-base/util/object';\n\nclass DynReducerUtils {\n    /**\n     * Checks for array equality between two arrays of numbers.\n     *\n     * @param a - Array A\n     *\n     * @param b - Array B\n     *\n     * @returns Arrays are equal.\n     */\n    static arrayEquals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        /* c8 ignore next */\n        if (a === null || b === null) {\n            return false;\n        }\n        /* c8 ignore next */\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let cntr = a.length; --cntr >= 0;) {\n            /* c8 ignore next */\n            if (a[cntr] !== b[cntr]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Provides a solid string hashing algorithm.\n     *\n     * Sourced from: https://stackoverflow.com/a/52171480\n     *\n     * @param str - String to hash.\n     *\n     * @param seed - A seed value altering the hash.\n     *\n     * @returns Hash code.\n     */\n    static hashString(str, seed = 0) {\n        /* c8 ignore next */\n        if (str === void 0 || str === null) {\n            return 0;\n        }\n        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n        for (let ch, i = 0; i < str.length; i++) {\n            ch = str.charCodeAt(i);\n            h1 = Math.imul(h1 ^ ch, 2654435761);\n            h2 = Math.imul(h2 ^ ch, 1597334677);\n        }\n        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n        return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n    }\n    /**\n     * Converts an unknown value for hashing purposes in {@link AdapterIndexer.calcHashUpdate}.\n     *\n     * Currently, objects / Map w/ object keys is not supported. Potentially can include `object-hash` to handle this\n     * case, but it is not common to use objects as keys in Maps.\n     *\n     * @param value - An unknown value to convert to a number.\n     */\n    static hashUnknown(value) {\n        if (value === null || value === void 0) {\n            return 0;\n        }\n        let result = 0;\n        switch (typeof value) {\n            case 'boolean':\n                result = value ? 1 : 0;\n                break;\n            case 'bigint':\n                result = Number(BigInt.asIntN(64, value));\n                break;\n            case 'function':\n                result = this.hashString(value.name);\n                break;\n            case 'number':\n                result = Number.isFinite(value) ? value : 0;\n                break;\n            case 'object':\n                // TODO: consider hashing an object IE `object-hash` and convert to number.\n                break;\n            case 'string':\n                result = this.hashString(value);\n                break;\n            case 'symbol':\n                result = this.hashString(Symbol.keyFor(value));\n                break;\n        }\n        return result;\n    }\n    /**\n     * @param target -\n     *\n     * @param Prototype -\n     *\n     * @returns target constructor function has Prototype.\n     */\n    static hasPrototype(target, Prototype) {\n        /* c8 ignore next */\n        if (typeof target !== 'function') {\n            return false;\n        }\n        if (target === Prototype) {\n            return true;\n        }\n        // Walk parent prototype chain. Check for descriptor at each prototype level.\n        for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {\n            if (proto === Prototype) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Provides a utility method to determine if the given data is iterable / implements iterator protocol.\n     *\n     * @param data - Data to verify as iterable.\n     *\n     * @returns Is data iterable.\n     */\n    static isIterable(data) {\n        return data !== null && data !== void 0 && typeof data === 'object' &&\n            typeof data[Symbol.iterator] === 'function';\n    }\n}\n\n/**\n * Provides the `derived` API for all dynamic reducers.\n */\nclass AdapterDerived {\n    #hostData;\n    #DerivedReducerCtor;\n    #parentIndex;\n    #derived = new Map();\n    #destroyed = false;\n    /**\n     * @param hostData - Hosted data structure.\n     *\n     * @param parentIndex - Any associated parent index API.\n     *\n     * @param DerivedReducerCtor - The default derived reducer constructor function.\n     */\n    constructor(hostData, parentIndex, DerivedReducerCtor) {\n        this.#hostData = hostData;\n        this.#parentIndex = parentIndex;\n        this.#DerivedReducerCtor = DerivedReducerCtor;\n        Object.freeze(this);\n    }\n    /**\n     * Creates a new derived reducer.\n     *\n     * @param options - Options defining the new derived reducer.\n     *\n     * @returns Newly created derived reducer.\n     */\n    create(options) {\n        if (this.#destroyed || this.#hostData === null) {\n            throw Error(`AdapterDerived.create error: this instance has been destroyed.`);\n        }\n        let name;\n        let rest = {};\n        let ctor;\n        const DerivedReducerCtor = this.#DerivedReducerCtor;\n        if (typeof options === 'string') {\n            name = options;\n            ctor = DerivedReducerCtor;\n        }\n        else if (typeof options === 'function' && DynReducerUtils.hasPrototype(options, DerivedReducerCtor)) {\n            ctor = options;\n        }\n        else if (typeof options === 'object' && options !== null) {\n            ({ name, ctor = DerivedReducerCtor, ...rest } = options);\n        }\n        else {\n            throw new TypeError(`AdapterDerived.create error: 'options' does not conform to allowed parameters.`);\n        }\n        if (!DynReducerUtils.hasPrototype(ctor, DerivedReducerCtor)) {\n            throw new TypeError(`AdapterDerived.create error: 'ctor' is not a '${DerivedReducerCtor?.name}'.`);\n        }\n        name = name ?? ctor?.name;\n        if (typeof name !== 'string') {\n            throw new TypeError(`AdapterDerived.create error: 'name' is not a string.`);\n        }\n        const derivedReducer = new ctor(this.#hostData, this.#parentIndex, rest);\n        this.#derived.set(name, derivedReducer);\n        // If the instantiated derived reducer has an `initialize` method then invoke it.\n        if (this.#hasInitialize(derivedReducer)) {\n            const { filters, sort, ...optionsRest } = rest;\n            derivedReducer.initialize(optionsRest);\n        }\n        return derivedReducer;\n    }\n    /**\n     * Removes all derived reducers and associated subscriptions.\n     */\n    clear() {\n        if (this.#destroyed) {\n            return;\n        }\n        for (const reducer of this.#derived.values()) {\n            reducer.destroy();\n        }\n        this.#derived.clear();\n    }\n    /**\n     * Deletes and destroys a derived reducer by name.\n     *\n     * @param name - Name of the derived reducer.\n     *\n     * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.\n     */\n    delete(name) {\n        if (this.#destroyed) {\n            throw Error(`AdapterDerived.delete error: this instance has been destroyed.`);\n        }\n        const reducer = this.#derived.get(name);\n        if (reducer) {\n            reducer.destroy();\n        }\n        return this.#derived.delete(name);\n    }\n    /**\n     * Removes all derived reducers, subscriptions, and cleans up all resources.\n     */\n    destroy() {\n        if (this.#destroyed) {\n            return;\n        }\n        this.clear();\n        this.#hostData = null;\n        this.#parentIndex = null;\n        this.#destroyed = true;\n    }\n    /**\n     * Returns an existing derived reducer.\n     *\n     * @param name - Name of derived reducer.\n     *\n     * @returns Any associated derived reducer.\n     */\n    get(name) {\n        if (this.#destroyed) {\n            throw Error(`AdapterDerived.get error: this instance has been destroyed.`);\n        }\n        return this.#derived.get(name);\n    }\n    /**\n     * Type guard to check for presence of `initialize` method.\n     *\n     * @param instance - Instance to check.\n     */\n    #hasInitialize(instance) {\n        return typeof instance?.initialize === 'function';\n    }\n    /**\n     * Updates all managed derived reducer indexes.\n     *\n     * @param [force=false] - Force an update to subscribers.\n     */\n    update(force = false) {\n        if (this.#destroyed) {\n            return;\n        }\n        for (const reducer of this.#derived.values()) {\n            reducer.index.update(force);\n        }\n    }\n}\n\nclass AdapterFilters {\n    #filtersData;\n    #indexUpdate;\n    #mapUnsubscribe = new Map();\n    constructor(indexUpdate, filtersAdapter) {\n        this.#indexUpdate = indexUpdate;\n        this.#filtersData = filtersAdapter;\n        Object.freeze(this);\n    }\n    get length() { return this.#filtersData.filters.length; }\n    *[Symbol.iterator]() {\n        if (this.#filtersData.filters.length === 0) {\n            return;\n        }\n        for (const entry of this.#filtersData.filters) {\n            yield { ...entry };\n        }\n    }\n    add(...filters) {\n        /**\n         * Tracks the number of filters added that have subscriber functionality.\n         */\n        let subscribeCount = 0;\n        for (const filter of filters) {\n            const filterType = typeof filter;\n            if (filterType !== 'function' && (filterType !== 'object' || filter === null)) {\n                throw new TypeError(`AdapterFilters error: 'filter' is not a function or object.`);\n            }\n            let data;\n            let subscribeFn;\n            if (filterType === 'function') {\n                data = {\n                    id: void 0,\n                    filter: filter,\n                    weight: 1\n                };\n                subscribeFn = filter.subscribe;\n            }\n            else if (filterType === 'object') {\n                if ('filter' in filter) {\n                    if (typeof filter.filter !== 'function') {\n                        throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);\n                    }\n                    if (filter.weight !== void 0 && (typeof filter.weight !== 'number' ||\n                        filter.weight < 0 || filter.weight > 1)) {\n                        throw new TypeError(`AdapterFilters error: 'weight' attribute is not a number between '0 - 1' inclusive.`);\n                    }\n                    data = {\n                        id: filter.id !== void 0 ? filter.id : void 0,\n                        filter: filter.filter,\n                        weight: filter.weight || 1\n                    };\n                    subscribeFn = filter.filter.subscribe ?? filter.subscribe;\n                }\n                else {\n                    throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);\n                }\n                /* c8 ignore next 5 */ // TS type guard for `else` conditional.\n            }\n            else {\n                throw new TypeError(`AdapterFilters error: 'filter' is not defined.`);\n            }\n            // Find the index to insert where data.weight is less than existing values weight.\n            const index = this.#filtersData.filters.findIndex((value) => {\n                return data.weight < value.weight;\n            });\n            // If an index was found insert at that location.\n            if (index >= 0) {\n                this.#filtersData.filters.splice(index, 0, data);\n            }\n            else // push to end of filters.\n             {\n                this.#filtersData.filters.push(data);\n            }\n            if (typeof subscribeFn === 'function') {\n                const unsubscribe = subscribeFn(this.#indexUpdate);\n                // Ensure that unsubscribe is a function.\n                if (typeof unsubscribe !== 'function') {\n                    throw new TypeError('AdapterFilters error: Filter has subscribe function, but no unsubscribe function is returned.');\n                }\n                // Ensure that the same filter is not subscribed to multiple times.\n                if (this.#mapUnsubscribe.has(data.filter)) {\n                    throw new Error('AdapterFilters error: Filter added already has an unsubscribe function registered.');\n                }\n                this.#mapUnsubscribe.set(data.filter, unsubscribe);\n                subscribeCount++;\n            }\n        }\n        // Filters with subscriber functionality are assumed to immediately invoke the `subscribe` callback. If the\n        // subscriber count is less than the amount of filters added then automatically trigger an index update manually.\n        if (subscribeCount < filters.length) {\n            this.#indexUpdate(true);\n        }\n    }\n    clear() {\n        this.#filtersData.filters.length = 0;\n        // Unsubscribe from all filters with subscription support.\n        for (const unsubscribe of this.#mapUnsubscribe.values()) {\n            unsubscribe();\n        }\n        this.#mapUnsubscribe.clear();\n        this.#indexUpdate();\n    }\n    remove(...filters) {\n        const length = this.#filtersData.filters.length;\n        if (length === 0) {\n            return;\n        }\n        for (const data of filters) {\n            // Handle the case that the filter may either be a function or a filter entry / object.\n            const actualFilter = typeof data === 'function' ? data : data !== null && typeof data === 'object' ?\n                data.filter : void 0;\n            if (!actualFilter) {\n                continue;\n            }\n            for (let cntr = this.#filtersData.filters.length; --cntr >= 0;) {\n                if (this.#filtersData.filters[cntr].filter === actualFilter) {\n                    this.#filtersData.filters.splice(cntr, 1);\n                    // Invoke any unsubscribe function for given filter then remove from tracking.\n                    let unsubscribe;\n                    if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualFilter)) === 'function') {\n                        unsubscribe();\n                        this.#mapUnsubscribe.delete(actualFilter);\n                    }\n                }\n            }\n        }\n        // Update the index a filter was removed.\n        if (length !== this.#filtersData.filters.length) {\n            this.#indexUpdate(true);\n        }\n    }\n    removeBy(callback) {\n        const length = this.#filtersData.filters.length;\n        if (length === 0) {\n            return;\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(`AdapterFilters error: 'callback' is not a function.`);\n        }\n        this.#filtersData.filters = this.#filtersData.filters.filter((data) => {\n            const remove = callback.call(callback, { ...data });\n            if (remove) {\n                let unsubscribe;\n                if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.filter)) === 'function') {\n                    unsubscribe();\n                    this.#mapUnsubscribe.delete(data.filter);\n                }\n            }\n            // Reverse remove boolean to properly filter / remove this filter.\n            return !remove;\n        });\n        if (length !== this.#filtersData.filters.length) {\n            this.#indexUpdate(true);\n        }\n    }\n    removeById(...ids) {\n        const length = this.#filtersData.filters.length;\n        if (length === 0) {\n            return;\n        }\n        this.#filtersData.filters = this.#filtersData.filters.filter((data) => {\n            let remove = 0;\n            for (const id of ids) {\n                remove |= (data.id === id ? 1 : 0);\n            }\n            // If not keeping invoke any unsubscribe function for given filter then remove from tracking.\n            if (!!remove) {\n                let unsubscribe;\n                if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.filter)) === 'function') {\n                    unsubscribe();\n                    this.#mapUnsubscribe.delete(data.filter);\n                }\n            }\n            return !remove; // Swap here to actually remove the item via array filter method.\n        });\n        if (length !== this.#filtersData.filters.length) {\n            this.#indexUpdate(true);\n        }\n    }\n}\n\n/**\n * Provides construction and management of indexed data when there are parent indexes or filter / sort functions\n * applied.\n */\nclass AdapterIndexer {\n    derivedAdapter;\n    filtersData;\n    hostData;\n    hostUpdate;\n    indexData;\n    sortData;\n    sortFn;\n    destroyed = false;\n    /**\n     * @param hostData - Hosted data structure.\n     *\n     * @param hostUpdate - Host update function invoked on index updates.\n     *\n     * @param [parentIndexer] - Any associated parent index API.\n     *\n     * @returns Indexer adapter instance.\n     */\n    constructor(hostData, hostUpdate, parentIndexer) {\n        this.hostData = hostData;\n        this.hostUpdate = hostUpdate;\n        this.indexData = { index: null, hash: null, reversed: false, parent: parentIndexer };\n    }\n    /**\n     * @returns Returns whether the index is active.\n     */\n    get active() {\n        return this.filtersData.filters.length > 0 || this.sortData.compareFn !== null ||\n            this.indexData.parent?.active === true;\n    }\n    /**\n     * @returns Returns length of reduced index.\n     */\n    get length() {\n        return this.indexData.index ? this.indexData.index.length : 0;\n    }\n    // -------------------------------------------------------------------------------------------------------------------\n    /**\n     * Calculates a new hash value for the new index array if any. If the new index array is null then the hash value\n     * is set to null. Set calculated new hash value to the index adapter hash value.\n     *\n     * After hash generation compare old and new hash values and perform an update if they are different. If they are\n     * equal check for array equality between the old and new index array and perform an update if they are not equal.\n     *\n     * @param oldIndex - Old index array.\n     *\n     * @param oldHash - Old index hash value.\n     *\n     * @param [force=false] - When true forces an update to subscribers.\n     */\n    calcHashUpdate(oldIndex, oldHash, force = false) {\n        // Use force if a boolean otherwise default to false.\n        const actualForce = typeof force === 'boolean' ? force : /* c8 ignore next */ false;\n        let newHash = null;\n        const newIndex = this.indexData.index;\n        if (newIndex) {\n            for (let cntr = newIndex.length; --cntr >= 0;) {\n                newHash ^= DynReducerUtils.hashUnknown(newIndex[cntr]) + 0x9e3779b9 + (newHash << 6) + (newHash >> 2);\n            }\n        }\n        this.indexData.hash = newHash;\n        if (actualForce || (oldHash === newHash ? !DynReducerUtils.arrayEquals(oldIndex, newIndex) : true)) {\n            this.hostUpdate();\n        }\n    }\n    /**\n     * Destroys all resources.\n     */\n    destroy() {\n        if (this.destroyed) {\n            return;\n        }\n        this.hostData = null;\n        this.indexData.index = null;\n        this.indexData.hash = null;\n        this.indexData.reversed = false;\n        this.indexData.parent = null;\n        this.destroyed = true;\n    }\n    /**\n     * Store associated filter and sort data that are constructed after the indexer.\n     *\n     * @param filtersData - Associated AdapterFilters instance.\n     *\n     * @param sortData - Associated AdapterSort instance.\n     *\n     * @param derivedAdapter - Associated AdapterDerived instance.\n     */\n    initAdapters(filtersData, sortData, derivedAdapter) {\n        this.filtersData = filtersData;\n        this.sortData = sortData;\n        this.derivedAdapter = derivedAdapter;\n        this.sortFn = this.createSortFn();\n    }\n}\n\nclass AdapterSort {\n    #sortData;\n    #indexUpdate;\n    #unsubscribe;\n    constructor(indexUpdate, sortData) {\n        this.#indexUpdate = indexUpdate;\n        this.#sortData = sortData;\n        Object.freeze(this);\n    }\n    clear() {\n        const oldCompareFn = this.#sortData.compareFn;\n        this.#sortData.compareFn = null;\n        if (typeof this.#unsubscribe === 'function') {\n            this.#unsubscribe();\n            this.#unsubscribe = void 0;\n        }\n        // Only update index if an old compare function is set.\n        if (typeof oldCompareFn === 'function') {\n            this.#indexUpdate(true);\n        }\n    }\n    set(sort) {\n        if (typeof this.#unsubscribe === 'function') {\n            this.#unsubscribe();\n            this.#unsubscribe = void 0;\n        }\n        let compareFn;\n        let subscribeFn;\n        switch (typeof sort) {\n            case 'function':\n                compareFn = sort;\n                subscribeFn = sort.subscribe;\n                break;\n            case 'object':\n                // Early out if sort is null / noop.\n                if (sort === null) {\n                    break;\n                }\n                if (typeof sort.compare !== 'function') {\n                    throw new TypeError(`AdapterSort error: 'compare' attribute is not a function.`);\n                }\n                compareFn = sort.compare;\n                subscribeFn = sort.compare.subscribe ?? sort.subscribe;\n                break;\n        }\n        if (typeof compareFn === 'function') {\n            this.#sortData.compareFn = compareFn;\n        }\n        else {\n            const oldCompareFn = this.#sortData.compareFn;\n            this.#sortData.compareFn = null;\n            // Update index if the old compare function exists.\n            if (typeof oldCompareFn === 'function') {\n                this.#indexUpdate();\n            }\n            return;\n        }\n        if (typeof subscribeFn === 'function') {\n            this.#unsubscribe = subscribeFn(this.#indexUpdate);\n            // Ensure that unsubscribe is a function.\n            if (typeof this.#unsubscribe !== 'function') {\n                throw new Error(`AdapterSort error: sort has 'subscribe' function, but no 'unsubscribe' function is returned.`);\n            }\n        }\n        else {\n            // A sort function with subscriber functionality are assumed to immediately invoke the `subscribe` callback.\n            // Only manually update the index if there is no subscriber functionality.\n            this.#indexUpdate(true);\n        }\n    }\n}\n\nclass IndexerAPI {\n    #indexData;\n    /**\n     * Provides a getter to determine if the index is active.\n     */\n    active;\n    /**\n     * Provides length of reduced / indexed elements.\n     */\n    length;\n    /**\n     * Manually invoke an update of the index.\n     *\n     * @param force - Force update to any subscribers.\n     */\n    update;\n    constructor(adapterIndexer) {\n        this.#indexData = adapterIndexer.indexData;\n        this.update = adapterIndexer.update.bind(adapterIndexer);\n        // Defines getters on the public API to get the index hash, active state, and index length.\n        Object.defineProperties(this, {\n            active: { get: () => adapterIndexer.active },\n            length: { get: () => adapterIndexer.length }\n        });\n        Object.freeze(this);\n    }\n    get hash() {\n        return this.#indexData.hash;\n    }\n    *[Symbol.iterator]() {\n        const indexData = this.#indexData;\n        if (!indexData.index) {\n            return;\n        }\n        const reversed = indexData.reversed;\n        const length = indexData.index.length;\n        if (reversed) {\n            for (let cntr = length; --cntr >= 0;) {\n                yield indexData.index[cntr];\n            }\n        }\n        else {\n            for (let cntr = 0; cntr < length; cntr++) {\n                yield indexData.index[cntr];\n            }\n        }\n    }\n}\n\n/**\n */\nclass ArrayIndexer extends AdapterIndexer {\n    /**\n     * @inheritDoc\n     */\n    createSortFn() {\n        return (a, b) => {\n            const data = this.hostData?.[0];\n            const dataA = data?.[a];\n            const dataB = data?.[b];\n            /* c8 ignore next */\n            return dataA && dataB ? this.sortData.compareFn(dataA, dataB) : 0;\n        };\n    }\n    /**\n     * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.\n     *\n     * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,\n     * but the maintenance factor is not worth the extra complication.\n     *\n     * @returns New filtered index array.\n     */\n    reduceImpl() {\n        const data = [];\n        const array = this.hostData?.[0];\n        if (!array) {\n            return data;\n        }\n        const filters = this.filtersData.filters;\n        let include = true;\n        const parentIndex = this.indexData.parent;\n        // Source index data is coming from an active parent index.\n        if (DynReducerUtils.isIterable(parentIndex) && parentIndex.active) {\n            for (const adjustedIndex of parentIndex) {\n                const value = array[adjustedIndex];\n                include = true;\n                for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {\n                    if (!filters[filCntr].filter(value)) {\n                        include = false;\n                        break;\n                    }\n                }\n                if (include) {\n                    data.push(adjustedIndex);\n                }\n            }\n        }\n        else {\n            for (let cntr = 0, length = array.length; cntr < length; cntr++) {\n                include = true;\n                for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {\n                    if (!filters[filCntr].filter(array[cntr])) {\n                        include = false;\n                        break;\n                    }\n                }\n                if (include) {\n                    data.push(cntr);\n                }\n            }\n        }\n        return data;\n    }\n    /**\n     * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally\n     * pass in true to force an update to subscribers.\n     *\n     * @param [force=false] - When true forces an update to subscribers.\n     */\n    update(force = false) {\n        if (this.destroyed) {\n            return;\n        }\n        const oldIndex = this.indexData.index;\n        const oldHash = this.indexData.hash;\n        const array = this.hostData?.[0];\n        const parentIndex = this.indexData.parent;\n        // Clear index if there are no filters and no sort function or the index length doesn't match the item length.\n        if ((this.filtersData.filters.length === 0 && !this.sortData.compareFn) ||\n            (this.indexData.index && array?.length !== this.indexData.index.length)) {\n            this.indexData.index = null;\n        }\n        // If there are filters build new index.\n        if (this.filtersData.filters.length > 0) {\n            this.indexData.index = this.reduceImpl();\n        }\n        // If the index isn't built yet and there is an active parent index then create it from the parent.\n        if (!this.indexData.index && parentIndex?.active) {\n            this.indexData.index = [...parentIndex];\n        }\n        if (this.sortData.compareFn && Array.isArray(array)) {\n            // If there is no index then create one with keys matching host item length.\n            if (!this.indexData.index) {\n                this.indexData.index = [...Array(array.length).keys()];\n            }\n            this.indexData.index.sort(this.sortFn);\n        }\n        this.calcHashUpdate(oldIndex, oldHash, force);\n        // Update all derived reducers.\n        this.derivedAdapter?.update(force);\n    }\n}\n\n/**\n * Provides a public API for managing derived reducers.\n */\nclass DerivedListAPI {\n    clear;\n    create;\n    delete;\n    destroy;\n    get;\n    constructor(adapterDerived) {\n        this.clear = adapterDerived.clear.bind(adapterDerived);\n        this.create = adapterDerived.create.bind(adapterDerived);\n        this.delete = adapterDerived.delete.bind(adapterDerived);\n        this.destroy = adapterDerived.destroy.bind(adapterDerived);\n        this.get = adapterDerived.get.bind(adapterDerived);\n        Object.freeze(this);\n    }\n}\n\n/**\n * Provides the base implementation derived reducer for arrays / DynArrayReducer.\n *\n * Note: That you should never directly create an instance of a derived reducer, but instead use the\n * {@link DynArrayReducerDerived.initialize} function to set up any initial state in a custom derived reducer.\n *\n * @typeParam T `unknown` - Type of data. Defaults to `unknown` to enforce type safety when no type is specified.\n */\nclass DynArrayReducerDerived {\n    #array;\n    #derived;\n    #derivedPublicAPI;\n    #filters;\n    #filtersData = { filters: [] };\n    #index;\n    #indexPublicAPI;\n    #sort;\n    #sortData = { compareFn: null };\n    #subscribers = [];\n    #destroyed = false;\n    /**\n     * @param array - Data host array.\n     *\n     * @param parentIndex - Parent indexer.\n     *\n     * @param options - Any filters and sort functions to apply.\n     *\n     * @typeParam T `unknown` - Type of data.\n     *\n     * @private\n     */\n    constructor(array, parentIndex, options) {\n        this.#array = array;\n        this.#index = new ArrayIndexer(this.#array, this.#updateSubscribers.bind(this), parentIndex);\n        this.#indexPublicAPI = new IndexerAPI(this.#index);\n        this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);\n        this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);\n        this.#derived = new AdapterDerived(this.#array, this.#indexPublicAPI, DynArrayReducerDerived);\n        this.#derivedPublicAPI = new DerivedListAPI(this.#derived);\n        this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);\n        const { filters, sort } = options;\n        if (filters !== void 0) {\n            if (!DynReducerUtils.isIterable(filters)) {\n                throw new TypeError(`DerivedArrayReducer error (DataDerivedOptions): 'filters' attribute is not iterable.`);\n            }\n            this.filters.add(...filters);\n        }\n        if (sort !== void 0) {\n            if (typeof sort !== 'function' && (typeof sort !== 'object' || sort === null)) {\n                throw new TypeError(`DerivedArrayReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.`);\n            }\n            this.sort.set(sort);\n        }\n    }\n    /**\n     * @returns Derived public API.\n     */\n    get derived() { return this.#derivedPublicAPI; }\n    /**\n     * @returns The filters adapter.\n     */\n    get filters() { return this.#filters; }\n    /**\n     * @returns Returns the Indexer public API; is also iterable.\n     */\n    get index() { return this.#indexPublicAPI; }\n    /**\n     * @returns Returns whether this derived reducer is destroyed.\n     */\n    get destroyed() { return this.#destroyed; }\n    /**\n     * @returns Returns the main data items or indexed items length.\n     */\n    get length() {\n        const array = this.#array?.[0];\n        return this.#index.active ? this.index.length :\n            array ? array.length : 0;\n    }\n    /**\n     * @returns Returns current reversed state.\n     */\n    get reversed() { return this.#index.indexData.reversed; }\n    /**\n     * @returns The sort adapter.\n     */\n    get sort() { return this.#sort; }\n    /**\n     * Sets reversed state and notifies subscribers.\n     *\n     * @param reversed - New reversed state.\n     */\n    set reversed(reversed) {\n        if (typeof reversed !== 'boolean') {\n            throw new TypeError(`DerivedArrayReducer.reversed error: 'reversed' is not a boolean.`);\n        }\n        this.#index.indexData.reversed = reversed;\n        // Recalculate index and force an update to any subscribers.\n        this.index.update(true);\n    }\n    /**\n     * Removes all derived reducers, subscriptions, and cleans up all resources.\n     */\n    destroy() {\n        this.#destroyed = true;\n        // Remove any external data reference and perform a final update.\n        this.#array = null;\n        this.index.update(true);\n        // Remove all subscriptions.\n        this.#subscribers.length = 0;\n        this.#derived.destroy();\n        this.#index.destroy();\n        this.#filters.clear();\n        this.#sort.clear();\n    }\n    /**\n     * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows\n     * child classes to avoid implementing the constructor.\n     *\n     * @param [optionsRest] - Any additional custom options passed beyond {@link DynReducer.Options.Common}.\n     *\n     * @protected\n     */\n    initialize(optionsRest) { }\n    /**\n     * Provides an iterator for data stored in DynArrayReducerDerived.\n     *\n     * @returns Iterator for data stored in DynArrayReducerDerived.\n     */\n    *[Symbol.iterator]() {\n        const array = this.#array?.[0] ?? null;\n        if (this.#destroyed || array === null || array?.length === 0) {\n            return;\n        }\n        if (this.#index.active) {\n            for (const entry of this.index) {\n                yield array[entry];\n            }\n        }\n        else {\n            if (this.reversed) {\n                for (let cntr = array.length; --cntr >= 0;) {\n                    yield array[cntr];\n                }\n            }\n            else {\n                for (let cntr = 0; cntr < array.length; cntr++) {\n                    yield array[cntr];\n                }\n            }\n        }\n    }\n    // -------------------------------------------------------------------------------------------------------------------\n    /**\n     * Subscribe to this DerivedArrayReducer.\n     *\n     * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.\n     *\n     * @returns Unsubscribe function.\n     */\n    subscribe(handler) {\n        const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n        if (currentIdx === -1) {\n            this.#subscribers.push(handler);\n            handler(this); // call handler with current value\n        }\n        // Return unsubscribe function.\n        return () => {\n            const existingIdx = this.#subscribers.findIndex((entry) => entry === handler);\n            if (existingIdx !== -1) {\n                this.#subscribers.splice(existingIdx, 1);\n            }\n        };\n    }\n    /**\n     * Updates subscribers on changes.\n     */\n    #updateSubscribers() {\n        for (let cntr = 0; cntr < this.#subscribers.length; cntr++) {\n            this.#subscribers[cntr](this);\n        }\n    }\n}\n\n/**\n * Provides a managed array with non-destructive reducing / filtering / sorting capabilities with subscription /\n * Svelte store support.\n *\n * _Note:_ In constructing a DynArrayReducer instance that arrays are treated as a special case. When an array is passed\n * in as `data` in the constructor it will be used as the host array and not copied. All non-array iterables otherwise\n * create a new array / copy.\n *\n * _Note:_\n * - The default type `unknown` ensures stricter type checking, preventing unintended operations on the data.\n * - If the type of data is known, explicitly specify the generic type to improve clarity and maintainability:\n *\n * @example\n * ```ts\n * // Using external array data as reducer host data.\n * const data = ['a', 'b', 'c'];\n * const reducer = new DynArrayReducer<string>(data);\n *\n * // Add new data externally.\n * data.push('d');\n *\n * // Update the index.\n * reducer.index.update();\n * ```\n *\n * @example\n * ```ts\n * // Explicit type specification.\n * const reducer = new DynArrayReducer<string>(['a', 'b', 'c']);\n * ```\n *\n * @example\n * ```ts\n * // Using the default type.\n * const reducer = new DynArrayReducer(); // Defaults to DynArrayReducer<unknown>\n * ```\n *\n * @typeParam T `unknown` - Type of data. Defaults to `unknown` to enforce type safety when no type is specified.\n */\nclass DynArrayReducer {\n    #array = [null];\n    #derived;\n    #derivedPublicAPI;\n    #filters;\n    #filtersData = { filters: [] };\n    #index;\n    #indexPublicAPI;\n    #sort;\n    #sortData = { compareFn: null };\n    #subscribers = [];\n    #destroyed = false;\n    /**\n     * Initializes DynArrayReducer. Any iterable is supported for initial data. Take note that if `data` is an array it\n     * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.\n     *\n     * @param [data] - Data iterable to store if array or copy otherwise.\n     *\n     * @typeParam T `unknown` - Type of data.\n     */\n    constructor(data) {\n        let dataIterable;\n        let filters;\n        let sort;\n        if (data === null) {\n            throw new TypeError(`DynArrayReducer error: 'data' is not iterable.`);\n        }\n        if (data !== void 0 && typeof data !== 'object' && !DynReducerUtils.isIterable(data)) {\n            throw new TypeError(`DynArrayReducer error: 'data' is not iterable.`);\n        }\n        if (data !== void 0 && Symbol.iterator in data) {\n            dataIterable = data;\n        }\n        else if (data !== void 0 && ('data' in data || 'filters' in data || 'sort' in data)) {\n            if (data.data !== void 0 && !DynReducerUtils.isIterable(data.data)) {\n                throw new TypeError(`DynArrayReducer error (DataDynArray): 'data' attribute is not iterable.`);\n            }\n            dataIterable = data.data;\n            if (data.filters !== void 0) {\n                if (DynReducerUtils.isIterable(data.filters)) {\n                    filters = data.filters;\n                }\n                else {\n                    throw new TypeError(`DynArrayReducer error (DataDynArray): 'filters' attribute is not iterable.`);\n                }\n            }\n            if (data.sort !== void 0) {\n                if (typeof data.sort === 'function') {\n                    sort = data.sort;\n                }\n                else if (typeof data.sort === 'object' && data.sort !== null) {\n                    sort = data.sort;\n                }\n                else {\n                    throw new TypeError(`DynArrayReducer error (DataDynArray): 'sort' attribute is not a function or object.`);\n                }\n            }\n        }\n        // In the case of the main data being an array directly use the array otherwise create a copy.\n        if (dataIterable) {\n            this.#array[0] = Array.isArray(dataIterable) ? dataIterable : [...dataIterable];\n        }\n        this.#index = new ArrayIndexer(this.#array, this.#updateSubscribers.bind(this));\n        this.#indexPublicAPI = new IndexerAPI(this.#index);\n        this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);\n        this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);\n        this.#derived = new AdapterDerived(this.#array, this.#indexPublicAPI, DynArrayReducerDerived);\n        this.#derivedPublicAPI = new DerivedListAPI(this.#derived);\n        this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);\n        // Add any filters and sort function defined by DataDynArray.\n        if (filters) {\n            this.filters.add(...filters);\n        }\n        if (sort) {\n            this.sort.set(sort);\n        }\n    }\n    /**\n     * Returns the internal data of this instance. Be careful!\n     *\n     * Note: if an array is set as initial data then that array is used as the internal data. If any changes are\n     * performed to the data externally do invoke `update` via {@link DynArrayReducer.index} with `true` to recalculate\n     * the index and notify all subscribers.\n     *\n     * @returns The internal data.\n     */\n    get data() { return this.#array[0]; }\n    /**\n     * @returns Derived public API.\n     */\n    get derived() { return this.#derivedPublicAPI; }\n    /**\n     * @returns The filters adapter.\n     */\n    get filters() { return this.#filters; }\n    /**\n     * @returns Returns the Indexer public API; is also iterable.\n     */\n    get index() { return this.#indexPublicAPI; }\n    /**\n     * @returns Returns whether this instance is destroyed.\n     */\n    get destroyed() { return this.#destroyed; }\n    /**\n     * @returns Returns the main data items or indexed items length.\n     */\n    get length() {\n        const array = this.#array[0];\n        return this.#index.active ? this.#indexPublicAPI.length :\n            array ? array.length : 0;\n    }\n    /**\n     * @returns Returns current reversed state.\n     */\n    get reversed() { return this.#index.indexData.reversed; }\n    /**\n     * @returns The sort adapter.\n     */\n    get sort() { return this.#sort; }\n    /**\n     * Sets reversed state and notifies subscribers.\n     *\n     * @param reversed - New reversed state.\n     */\n    set reversed(reversed) {\n        if (typeof reversed !== 'boolean') {\n            throw new TypeError(`DynArrayReducer.reversed error: 'reversed' is not a boolean.`);\n        }\n        this.#index.indexData.reversed = reversed;\n        // Recalculate index and force an update to any subscribers.\n        this.index.update(true);\n    }\n    /**\n     * Removes all derived reducers, subscriptions, and cleans up all resources.\n     */\n    destroy() {\n        if (this.#destroyed) {\n            return;\n        }\n        this.#destroyed = true;\n        this.#derived.destroy();\n        // Set the backing data to null and provide a final update.\n        this.#array = [null];\n        this.index.update(true);\n        // Remove all subscriptions.\n        this.#subscribers.length = 0;\n        this.#filters.clear();\n        this.#sort.clear();\n        this.#index.destroy();\n    }\n    /**\n     * Provides a callback for custom reducers to initialize any data / custom configuration. Depending on the consumer\n     * of `dynamic-reducer` this may be utilized allowing child classes to avoid implementing the constructor.\n     *\n     * @param [optionsRest] - Any additional custom options passed beyond {@link DynReducer.Options.Common}.\n     *\n     * @protected\n     */\n    /* c8 ignore next */\n    initialize(optionsRest) { }\n    /**\n     * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless\n     * `replace` is set to true.\n     *\n     * @param data - New data to set to internal data.\n     *\n     * @param [replace=false] - New data to set to internal data.\n     */\n    setData(data, replace = false) {\n        if (data !== null && !DynReducerUtils.isIterable(data)) {\n            throw new TypeError(`DynArrayReducer.setData error: 'data' is not iterable.`);\n        }\n        if (typeof replace !== 'boolean') {\n            throw new TypeError(`DynArrayReducer.setData error: 'replace' is not a boolean.`);\n        }\n        const array = this.#array[0];\n        // If the array isn't defined or 'replace' is true then replace internal data with new array or create an array\n        // from an iterable.\n        if (!Array.isArray(array) || replace) {\n            if (data) {\n                this.#array[0] = Array.isArray(data) ? data : [...data];\n            }\n        }\n        else {\n            if (data) {\n                // Remove all entries in internal data. This will not replace any initially set array.\n                array.length = 0;\n                // Add all new data.\n                array.push(...data);\n            }\n            else {\n                this.#array[0] = null;\n            }\n        }\n        // Force clear the index and always rebuild.\n        this.#index.indexData.index = null;\n        // Recalculate index and force an update to any subscribers.\n        this.index.update(true);\n    }\n    /**\n     * Add a subscriber to this DynArrayReducer instance.\n     *\n     * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.\n     *\n     * @returns Unsubscribe function.\n     */\n    subscribe(handler) {\n        const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n        if (currentIdx === -1) {\n            this.#subscribers.push(handler);\n            handler(this); // call handler with current value\n        }\n        // Return unsubscribe function.\n        return () => {\n            const existingIdx = this.#subscribers.findIndex((entry) => entry === handler);\n            if (existingIdx !== -1) {\n                this.#subscribers.splice(existingIdx, 1);\n            }\n        };\n    }\n    /**\n     * Updates subscribers on changes.\n     */\n    #updateSubscribers() {\n        for (let cntr = 0; cntr < this.#subscribers.length; cntr++) {\n            this.#subscribers[cntr](this);\n        }\n    }\n    /**\n     * Provides an iterator for data stored in DynArrayReducer.\n     *\n     * @returns Iterator for data stored in DynArrayReducer.\n     */\n    *[Symbol.iterator]() {\n        const array = this.#array[0];\n        if (this.#destroyed || array === null || array?.length === 0) {\n            return;\n        }\n        if (this.#index.active) {\n            for (const entry of this.index) {\n                yield array[entry];\n            }\n        }\n        else {\n            if (this.reversed) {\n                for (let cntr = array.length; --cntr >= 0;) {\n                    yield array[cntr];\n                }\n            }\n            else {\n                for (let cntr = 0; cntr < array.length; cntr++) {\n                    yield array[cntr];\n                }\n            }\n        }\n    }\n}\n\n/**\n */\nclass MapIndexer extends AdapterIndexer {\n    /**\n     * @inheritDoc\n     */\n    createSortFn() {\n        return (a, b) => {\n            const data = this.hostData?.[0];\n            const dataA = data?.get(a);\n            const dataB = data?.get(b);\n            /* c8 ignore next */\n            return dataA && dataB ? this.sortData.compareFn(dataA, dataB) : 0;\n        };\n    }\n    /**\n     * Provides the custom filter / reduce step that is ~25-40% faster than implementing with `Array.reduce`.\n     *\n     * Note: Other loop unrolling techniques like Duff's Device gave a slight faster lower bound on large data sets,\n     * but the maintenance factor is not worth the extra complication.\n     *\n     * @returns New filtered index array.\n     */\n    reduceImpl() {\n        const data = [];\n        const map = this.hostData?.[0];\n        if (!map) {\n            return data;\n        }\n        const filters = this.filtersData.filters;\n        let include = true;\n        const parentIndex = this.indexData.parent;\n        // Source index data is coming from an active parent index.\n        if (DynReducerUtils.isIterable(parentIndex) && parentIndex.active) {\n            for (const key of parentIndex) {\n                const value = map.get(key);\n                include = true;\n                /* c8 ignore next */\n                if (value === undefined) {\n                    continue;\n                }\n                for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {\n                    if (!filters[filCntr].filter(value)) {\n                        include = false;\n                        break;\n                    }\n                }\n                if (include) {\n                    data.push(key);\n                }\n            }\n        }\n        else {\n            for (const key of map.keys()) {\n                include = true;\n                const value = map.get(key);\n                /* c8 ignore next */\n                if (value === void 0) {\n                    continue;\n                }\n                for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {\n                    if (!filters[filCntr].filter(value)) {\n                        include = false;\n                        break;\n                    }\n                }\n                if (include) {\n                    data.push(key);\n                }\n            }\n        }\n        return data;\n    }\n    /**\n     * Update the reducer indexes. If there are changes subscribers are notified. If data order is changed externally\n     * pass in true to force an update to subscribers.\n     *\n     * @param [force=false] - When true forces an update to subscribers.\n     */\n    update(force = false) {\n        if (this.destroyed) {\n            return;\n        }\n        const oldIndex = this.indexData.index;\n        const oldHash = this.indexData.hash;\n        const map = this.hostData?.[0];\n        const parentIndex = this.indexData.parent;\n        // Clear index if there are no filters and no sort function or the index length doesn't match the item length.\n        if ((this.filtersData.filters.length === 0 && !this.sortData.compareFn) ||\n            (this.indexData.index && map?.size !== this.indexData.index.length)) {\n            this.indexData.index = null;\n        }\n        // If there are filters build new index.\n        if (this.filtersData.filters.length > 0) {\n            this.indexData.index = this.reduceImpl();\n        }\n        // If the index isn't built yet and there is an active parent index then create it from the parent.\n        if (!this.indexData.index && parentIndex?.active) {\n            this.indexData.index = [...parentIndex];\n        }\n        if (this.sortData.compareFn && map instanceof Map) {\n            // If there is no index then create one with keys matching host item length.\n            if (!this.indexData.index) {\n                this.indexData.index = [...map.keys()];\n            }\n            this.indexData.index.sort(this.sortFn);\n        }\n        this.calcHashUpdate(oldIndex, oldHash, force);\n        // Update all derived reducers.\n        this.derivedAdapter?.update(force);\n    }\n}\n\n/**\n * Provides a public API for managing derived reducers.\n */\nclass DerivedMapAPI {\n    clear;\n    create;\n    delete;\n    destroy;\n    get;\n    constructor(adapterDerived) {\n        this.clear = adapterDerived.clear.bind(adapterDerived);\n        this.create = adapterDerived.create.bind(adapterDerived);\n        this.delete = adapterDerived.delete.bind(adapterDerived);\n        this.destroy = adapterDerived.destroy.bind(adapterDerived);\n        this.get = adapterDerived.get.bind(adapterDerived);\n        Object.freeze(this);\n    }\n}\n\n/**\n * Provides the base implementation derived reducer for Maps / DynMapReducer.\n *\n * Note: That you should never directly create an instance of a derived reducer, but instead use the\n * {@link DynMapReducerDerived.initialize} function to set up any initial state in a custom derived reducer.\n *\n * @typeParam K `unknown` - Key type. Defaults to `unknown` to enforce type safety when no type is specified.\n *\n * @typeParam T `unknown` - Type of data. Defaults to `unknown` to enforce type safety when no type is specified.\n */\nclass DynMapReducerDerived {\n    #map;\n    #derived;\n    #derivedPublicAPI;\n    #filters;\n    #filtersData = { filters: [] };\n    #index;\n    #indexPublicAPI;\n    #sort;\n    #sortData = { compareFn: null };\n    #subscribers = [];\n    #destroyed = false;\n    /**\n     * @param map - Data host Map.\n     *\n     * @param parentIndex - Parent indexer.\n     *\n     * @param options - Any filters and sort functions to apply.\n     *\n     * @typeParam K `unknown` - Key type.\n     *\n     * @typeParam T `unknown` - Type of data.\n     *\n     * @private\n     */\n    constructor(map, parentIndex, options) {\n        this.#map = map;\n        this.#index = new MapIndexer(this.#map, this.#updateSubscribers.bind(this), parentIndex);\n        this.#indexPublicAPI = new IndexerAPI(this.#index);\n        this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);\n        this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);\n        this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DynMapReducerDerived);\n        this.#derivedPublicAPI = new DerivedMapAPI(this.#derived);\n        this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);\n        const { filters, sort } = options;\n        if (filters !== void 0) {\n            if (!DynReducerUtils.isIterable(filters)) {\n                throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'filters' attribute is not iterable.`);\n            }\n            this.filters.add(...filters);\n        }\n        if (sort !== void 0) {\n            if (typeof sort !== 'function' && (typeof sort !== 'object' || sort === null)) {\n                throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.`);\n            }\n            this.sort.set(sort);\n        }\n    }\n    /**\n     * @returns Derived public API.\n     */\n    get derived() { return this.#derivedPublicAPI; }\n    /**\n     * @returns The filters adapter.\n     */\n    get filters() { return this.#filters; }\n    /**\n     * @returns Returns the Indexer public API; is also iterable.\n     */\n    get index() { return this.#indexPublicAPI; }\n    /**\n     * @returns Returns whether this derived reducer is destroyed.\n     */\n    get destroyed() { return this.#destroyed; }\n    /**\n     * @returns Returns the main data items or indexed items length.\n     */\n    get length() {\n        const map = this.#map?.[0];\n        return this.#index.active ? this.index.length :\n            map ? map.size : 0;\n    }\n    /**\n     * @returns Returns current reversed state.\n     */\n    get reversed() { return this.#index.indexData.reversed; }\n    /**\n     * @returns Returns the sort adapter.\n     */\n    get sort() { return this.#sort; }\n    /**\n     * Sets reversed state and notifies subscribers.\n     *\n     * @param reversed - New reversed state.\n     */\n    set reversed(reversed) {\n        if (typeof reversed !== 'boolean') {\n            throw new TypeError(`DerivedMapReducer.reversed error: 'reversed' is not a boolean.`);\n        }\n        this.#index.indexData.reversed = reversed;\n        // Recalculate index and force an update to any subscribers.\n        this.index.update(true);\n    }\n    /**\n     * Removes all derived reducers, subscriptions, and cleans up all resources.\n     */\n    destroy() {\n        this.#destroyed = true;\n        // Remove any external data reference and perform a final update.\n        this.#map = [null];\n        this.#index.update(true);\n        // Remove all subscriptions.\n        this.#subscribers.length = 0;\n        this.#derived.destroy();\n        this.#index.destroy();\n        this.#filters.clear();\n        this.#sort.clear();\n    }\n    /**\n     * Provides a callback for custom derived reducers to initialize any data / custom configuration. This allows\n     * child classes to avoid implementing the constructor.\n     *\n     * @param [optionsRest] - Any additional custom options passed beyond {@link DynDataOptions}.\n     *\n     * @protected\n     */\n    initialize(optionsRest) { }\n    /**\n     * Provides an iterator for data stored in DynMapReducerDerived.\n     *\n     * @returns Iterator for data stored in DynMapReducerDerived.\n     */\n    *[Symbol.iterator]() {\n        const map = this.#map?.[0] ?? null;\n        if (this.#destroyed || map === null || map?.size === 0) {\n            return;\n        }\n        if (this.#index.active) {\n            for (const key of this.index) {\n                yield map.get(key);\n            }\n        }\n        else {\n            if (this.reversed) {\n                // TODO: Not efficient due to creating temporary values array.\n                const values = [...map.values()];\n                for (let cntr = values.length; --cntr >= 0;) {\n                    yield values[cntr];\n                }\n            }\n            else {\n                for (const value of map.values()) {\n                    yield value;\n                }\n            }\n        }\n    }\n    // -------------------------------------------------------------------------------------------------------------------\n    /**\n     * Subscribe to this DerivedMapReducer.\n     *\n     * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.\n     *\n     * @returns Unsubscribe function.\n     */\n    subscribe(handler) {\n        const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n        if (currentIdx === -1) {\n            this.#subscribers.push(handler);\n            handler(this); // call handler with current value\n        }\n        // Return unsubscribe function.\n        return () => {\n            const existingIdx = this.#subscribers.findIndex((entry) => entry === handler);\n            if (existingIdx !== -1) {\n                this.#subscribers.splice(existingIdx, 1);\n            }\n        };\n    }\n    /**\n     * Updates subscribers on changes.\n     */\n    #updateSubscribers() {\n        for (let cntr = 0; cntr < this.#subscribers.length; cntr++) {\n            this.#subscribers[cntr](this);\n        }\n    }\n}\n\n/**\n * Provides a managed {@link Map} with non-destructive reducing / filtering / sorting capabilities with subscription /\n * Svelte store support allowing for a {@link Map} to be treated like an iterable list.\n *\n * _Note:_\n * - The default type `unknown` ensures stricter type checking, preventing unintended operations on the data.\n * - If the type of data is known, explicitly specify the generic type to improve clarity and maintainability:\n *\n * @example\n * ```ts\n * const mapReducer = new DynMapReducer<number, string>(\n *     new Map([\n *         [1, 'banana'],\n *         [2, 'apple'],\n *         [3, 'cherry'],\n *     ])\n * );\n *\n * console.log([...mapReducer]); // Output: ['banana', 'apple', 'cherry']\n *\n * // Sort values alphabetically.\n * mapReducer.sort.set((a, b) => a.localeCompare(b));\n *\n * console.log([...mapReducer]); // Output: ['apple', 'banana', 'cherry']\n * ```\n *\n * @typeParam K `unknown` - Key type. Defaults to `unknown` to enforce type safety when no type is specified.\n *\n * @typeParam T `unknown` - Type of data. Defaults to `unknown` to enforce type safety when no type is specified.\n */\nclass DynMapReducer {\n    #map = [null];\n    #derived;\n    #derivedPublicAPI;\n    #filters;\n    #filtersData = { filters: [] };\n    #index;\n    #indexPublicAPI;\n    #sort;\n    #sortData = { compareFn: null };\n    #subscribers = [];\n    #destroyed = false;\n    /**\n     * Initializes DynMapReducer. Any iterable is supported for initial data. Take note that if `data` is an array it\n     * will be used as the host array and not copied. All non-array iterables otherwise create a new array / copy.\n     *\n     * @param [data] - Data iterable to store if array or copy otherwise.\n     *\n     * @typeParam K `unknown` - Key type.\n     *\n     * @typeParam T `unknown` - Type of data.\n     */\n    constructor(data) {\n        let dataMap;\n        let filters;\n        let sort;\n        if (data === null) {\n            throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);\n        }\n        if (data !== void 0 && typeof data !== 'object' && !(data instanceof Map)) {\n            throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);\n        }\n        if (data !== void 0 && data instanceof Map) {\n            dataMap = data;\n        }\n        else if (data !== void 0 && ('data' in data || 'filters' in data || 'sort' in data)) {\n            if (data.data !== void 0 && !(data.data instanceof Map)) {\n                throw new TypeError(`DynMapReducer error (DataDynMap): 'data' attribute is not a Map.`);\n            }\n            if (data.data instanceof Map) {\n                dataMap = data.data;\n            }\n            if (data.filters !== void 0) {\n                if (DynReducerUtils.isIterable(data.filters)) {\n                    filters = data.filters;\n                }\n                else {\n                    throw new TypeError(`DynMapReducer error (DataDynMap): 'filters' attribute is not iterable.`);\n                }\n            }\n            if (data.sort !== void 0) {\n                if (typeof data.sort === 'function') {\n                    sort = data.sort;\n                }\n                else if (typeof data.sort === 'object' && data.sort !== null) {\n                    sort = data.sort;\n                }\n                else {\n                    throw new TypeError(`DynMapReducer error (DataDynMap): 'sort' attribute is not a function or object.`);\n                }\n            }\n        }\n        // In the case of the main data being an array directly use the array otherwise create a copy.\n        if (dataMap) {\n            this.#map[0] = dataMap;\n        }\n        this.#index = new MapIndexer(this.#map, this.#updateSubscribers.bind(this));\n        this.#indexPublicAPI = new IndexerAPI(this.#index);\n        this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);\n        this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);\n        this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DynMapReducerDerived);\n        this.#derivedPublicAPI = new DerivedMapAPI(this.#derived);\n        this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);\n        // Add any filters and sort function defined by DataDynMap.\n        if (filters) {\n            this.filters.add(...filters);\n        }\n        if (sort) {\n            this.sort.set(sort);\n        }\n    }\n    /**\n     * Returns the internal data of this instance. Be careful!\n     *\n     * Note: When a map is set as data then that map is used as the internal data. If any changes are performed to the\n     * data externally do invoke `update` via {@link DynMapReducer.index} with `true` to recalculate the  index and\n     * notify all subscribers.\n     *\n     * @returns The internal data.\n     */\n    get data() { return this.#map[0]; }\n    /**\n     * @returns Derived public API.\n     */\n    get derived() { return this.#derivedPublicAPI; }\n    /**\n     * @returns The filters adapter.\n     */\n    get filters() { return this.#filters; }\n    /**\n     * @returns Returns the Indexer public API; is also iterable.\n     */\n    get index() { return this.#indexPublicAPI; }\n    /**\n     * @returns Returns whether this instance is destroyed.\n     */\n    get destroyed() { return this.#destroyed; }\n    /**\n     * @returns Returns the main data items or indexed items length.\n     */\n    get length() {\n        const map = this.#map[0];\n        return this.#index.active ? this.#indexPublicAPI.length :\n            map ? map.size : 0;\n    }\n    /**\n     * @returns Returns current reversed state.\n     */\n    get reversed() { return this.#index.indexData.reversed; }\n    /**\n     * @returns The sort adapter.\n     */\n    get sort() { return this.#sort; }\n    /**\n     * Sets reversed state and notifies subscribers.\n     *\n     * @param reversed - New reversed state.\n     */\n    set reversed(reversed) {\n        if (typeof reversed !== 'boolean') {\n            throw new TypeError(`DynMapReducer.reversed error: 'reversed' is not a boolean.`);\n        }\n        this.#index.indexData.reversed = reversed;\n        // Recalculate index and force an update to any subscribers.\n        this.index.update(true);\n    }\n    /**\n     * Removes all derived reducers, subscriptions, and cleans up all resources.\n     */\n    destroy() {\n        if (this.#destroyed) {\n            return;\n        }\n        this.#destroyed = true;\n        this.#derived.destroy();\n        // Set the backing data to null and provide a final update.\n        this.#map = [null];\n        this.index.update(true);\n        // Remove all subscriptions.\n        this.#subscribers.length = 0;\n        this.#filters.clear();\n        this.#sort.clear();\n        this.#index.destroy();\n    }\n    /**\n     * Provides a callback for custom reducers to initialize any data / custom configuration. Depending on the consumer\n     * of `dynamic-reducer` this may be utilized allowing child classes to avoid implementing the constructor.\n     *\n     * @param [optionsRest] - Any additional custom options passed beyond {@link DynReducer.Options.Common}.\n     *\n     * @protected\n     */\n    /* c8 ignore next */\n    initialize(optionsRest) { }\n    /**\n     * Removes internal data and pushes new data. This does not destroy any initial array set to internal data unless\n     * `replace` is set to true.\n     *\n     * @param data - New data to set to internal data.\n     *\n     * @param [replace=false] - New data to set to internal data.\n     */\n    setData(data, replace = false) {\n        if (data !== null && !(data instanceof Map)) {\n            throw new TypeError(`DynMapReducer.setData error: 'data' is not iterable.`);\n        }\n        if (typeof replace !== 'boolean') {\n            throw new TypeError(`DynMapReducer.setData error: 'replace' is not a boolean.`);\n        }\n        const map = this.#map[0];\n        // If the array isn't defined or 'replace' is true then replace internal data with new array or create an array\n        // from an iterable.\n        if (!(map instanceof Map) || replace) {\n            this.#map[0] = data instanceof Map ? data : null;\n        }\n        else if (data instanceof Map && map instanceof Map) {\n            // Create a set of all current entry IDs.\n            const removeKeySet = new Set(map.keys());\n            for (const key of data.keys()) {\n                map.set(key, data.get(key));\n                if (removeKeySet.has(key)) {\n                    removeKeySet.delete(key);\n                }\n            }\n            // Remove entries that are no longer in data.\n            for (const key of removeKeySet) {\n                map.delete(key);\n            }\n        }\n        else if (data === null) {\n            this.#map[0] = null;\n        }\n        // Force clear the index and always rebuild.\n        this.#index.indexData.index = null;\n        // Recalculate index and force an update to any subscribers.\n        this.index.update(true);\n    }\n    /**\n     * Add a subscriber to this DynMapReducer instance.\n     *\n     * @param handler - Callback function that is invoked on update / changes. Receives `this` reference.\n     *\n     * @returns Unsubscribe function.\n     */\n    subscribe(handler) {\n        const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n        if (currentIdx === -1) {\n            this.#subscribers.push(handler);\n            handler(this); // call handler with current value\n        }\n        // Return unsubscribe function.\n        return () => {\n            const existingIdx = this.#subscribers.findIndex((entry) => entry === handler);\n            if (existingIdx !== -1) {\n                this.#subscribers.splice(existingIdx, 1);\n            }\n        };\n    }\n    /**\n     * Updates subscribers on changes.\n     */\n    #updateSubscribers() {\n        for (let cntr = 0; cntr < this.#subscribers.length; cntr++) {\n            this.#subscribers[cntr](this);\n        }\n    }\n    /**\n     * Provides an iterator for data stored in DynMapReducer.\n     *\n     * @returns Iterator for data stored in DynMapReducer.\n     */\n    *[Symbol.iterator]() {\n        const map = this.#map[0];\n        if (this.#destroyed || map === null || map?.size === 0) {\n            return;\n        }\n        if (this.#index.active) {\n            for (const key of this.index) {\n                yield map.get(key);\n            }\n        }\n        else {\n            if (this.reversed) {\n                // TODO: Not efficient due to creating temporary values array.\n                const values = [...map.values()];\n                for (let cntr = values.length; --cntr >= 0;) {\n                    yield values[cntr];\n                }\n            }\n            else {\n                for (const value of map.values()) {\n                    yield value;\n                }\n            }\n        }\n    }\n}\n\n/**\n * Creates a filter function to compare objects by a given accessor key against a regex test. The returned function\n * is also a writable Svelte store that builds a regex from the stores value.\n *\n * This filter function can be used w/ a dynamic reducer and bound as a store to input elements.\n *\n * @param accessors - Property key / accessors to lookup key to compare. To access deeper\n *        entries into the object format the accessor string with `.` between entries to walk.\n *\n * @param [opts] - Optional parameters.\n *\n * @param [opts.accessWarn=false] - When true warnings will be posted if accessor not retrieved.\n *\n * @param [opts.caseSensitive=false] - When true regex test is case-sensitive.\n *\n * @param [opts.store] - Use the provided minimal writable store to instead of creating a default `writable` store.\n *\n * @returns The query string filter.\n */\nfunction regexObjectQuery(accessors, { accessWarn = false, caseSensitive = false, store } = {}) {\n    let keyword = '';\n    let regex;\n    if (store !== void 0 && !isMinimalWritableStore(store)) {\n        throw new TypeError(`regexObjectQuery error: 'store' is not a minimal writable store.`);\n    }\n    const storeKeyword = store ? store : writable(keyword);\n    // If an existing store is provided then set initial values.\n    if (store) {\n        const current = get(store);\n        if (typeof current === 'string') {\n            keyword = Strings.normalize(current);\n            regex = new RegExp(Strings.escape(keyword), caseSensitive ? '' : 'i');\n        }\n        else {\n            store.set(keyword);\n        }\n    }\n    const filterQuery = Object.assign(\n    /**\n     * If there is no filter keyword / regex then do not filter otherwise filter based on the regex\n     * created from the search input element.\n     *\n     * @param data - Data object to test against regex.\n     *\n     * @returns Store filter state.\n     */\n    (data) => {\n        if (keyword === '' || !regex) {\n            return true;\n        }\n        if (isIterable(accessors)) {\n            for (const accessor of accessors) {\n                const value = safeAccess(data, accessor);\n                if (typeof value !== 'string') {\n                    if (accessWarn) {\n                        console.warn(`regexObjectQuery warning: could not access string data from '${accessor}'.`);\n                    }\n                    continue;\n                }\n                if (regex.test(Strings.normalize(value))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else {\n            const value = safeAccess(data, accessors);\n            if (typeof value !== 'string') {\n                if (accessWarn) {\n                    console.warn(`regexObjectQuery warning: could not access string data from '${accessors}'.`);\n                }\n                return false;\n            }\n            return regex.test(Strings.normalize(value));\n        }\n    }, {\n        /**\n         * Create a custom store that changes when the search keyword changes.\n         *\n         * @param handler - A callback function that accepts strings.\n         *\n         * @returns Store unsubscribe function.\n         */\n        subscribe(handler) {\n            return storeKeyword.subscribe(handler);\n        },\n        /**\n         * @param value - A new value for the keyword / regex test.\n         */\n        set(value) {\n            if (typeof value === 'string') {\n                keyword = Strings.normalize(value);\n                regex = new RegExp(Strings.escape(keyword), caseSensitive ? '' : 'i');\n                storeKeyword.set(keyword);\n            }\n        }\n    });\n    /**\n     * Create a custom store that changes when the search keyword changes.\n     *\n     * @param handler - A callback function that accepts strings.\n     *\n     * @returns Store unsubscribe function.\n     */\n    filterQuery.subscribe = (handler) => {\n        return storeKeyword.subscribe(handler);\n    };\n    /**\n     * @param value - A new value for the keyword / regex test.\n     */\n    filterQuery.set = (value) => {\n        if (typeof value === 'string') {\n            keyword = Strings.normalize(value);\n            regex = new RegExp(Strings.escape(keyword), caseSensitive ? '' : 'i');\n            storeKeyword.set(keyword);\n        }\n    };\n    //\n    // /**\n    //  * If there is no filter keyword / regex then do not filter otherwise filter based on the regex\n    //  * created from the search input element.\n    //  *\n    //  * @param data - Data object to test against regex.\n    //  *\n    //  * @returns Store filter state.\n    //  */\n    // const filterQuery: ReturnType<DynReducerHelper.filters['regexObjectQuery']> = function(data: { [key: string]: any }): boolean\n    // {\n    //    if (keyword === '' || !regex) { return true; }\n    //\n    //    if (isIterable(accessors))\n    //    {\n    //       for (const accessor of accessors)\n    //       {\n    //          const value: any = safeAccess(data, accessor);\n    //          if (typeof value !== 'string')\n    //          {\n    //             if (accessWarn)\n    //             {\n    //                console.warn(`regexObjectQuery warning: could not access string data from '${accessor}'.`);\n    //             }\n    //\n    //             continue;\n    //          }\n    //\n    //          if (regex.test(Strings.normalize(value))) { return true; }\n    //       }\n    //\n    //       return false;\n    //    }\n    //    else\n    //    {\n    //       const value: any = safeAccess(data, accessors);\n    //       if (typeof value !== 'string')\n    //       {\n    //          if (accessWarn)\n    //          {\n    //             console.warn(`regexObjectQuery warning: could not access string data from '${accessors}'.`);\n    //          }\n    //\n    //          return false;\n    //       }\n    //\n    //       return regex.test(Strings.normalize(value));\n    //    }\n    // }\n    //\n    // /**\n    //  * Create a custom store that changes when the search keyword changes.\n    //  *\n    //  * @param handler - A callback function that accepts strings.\n    //  *\n    //  * @returns Store unsubscribe function.\n    //  */\n    // filterQuery.subscribe = (handler: Subscriber<string>): Unsubscriber =>\n    // {\n    //    return storeKeyword.subscribe(handler);\n    // };\n    //\n    // /**\n    //  * @param value - A new value for the keyword / regex test.\n    //  */\n    // filterQuery.set = (value: string): void =>\n    // {\n    //    if (typeof value === 'string')\n    //    {\n    //       keyword = Strings.normalize(value);\n    //       regex = new RegExp(Strings.escape(keyword), caseSensitive ? '' : 'i');\n    //       storeKeyword.set(keyword);\n    //    }\n    // };\n    return filterQuery;\n}\n\nconst filters = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    regexObjectQuery: regexObjectQuery\n});\n\n/**\n * Provides helper functions to create dynamic store driven filters and sort functions for dynamic reducers. The\n * returned functions are also Svelte stores and can be added to a reducer as well as used as a store.\n */\nclass DynReducerHelper {\n    constructor() { }\n    /**\n     * Returns the following filter functions:\n     * - regexObjectQuery(accessors, options); suitable for object reducers matching one or more property keys /\n     *   accessors against the store value as a regex. To access deeper entries into the object format the accessor\n     *   string with `.` between entries to walk. Optional parameters include logging access warnings, case sensitivity,\n     *   and passing in an existing store.\n     *\n     * @returns All available filters.\n     */\n    static get filters() { return filters; }\n}\n\nexport { DynArrayReducer, DynArrayReducerDerived, DynMapReducer, DynMapReducerDerived, DynReducerHelper };\n//# sourceMappingURL=index.js.map\n", "/**\n * Provides TypeScript type guards for several Foundry document model classes and objects.\n *\n * @packageDocumentation\n */\n/**\n * @param doc - A potential Foundry document.\n *\n * @returns Whether the given object is a Foundry document.\n */\nfunction isDocument(doc) {\n    return doc !== void 0 && doc !== null && doc instanceof foundry.abstract.Document;\n}\n/**\n * @param doc - A potential Foundry document class.\n *\n * @returns Whether the given object is a Foundry document class.\n */\nfunction isDocumentClass(doc) {\n    return doc !== void 0 && doc !== null && Object.prototype.isPrototypeOf.call(foundry.abstract.Document, doc);\n}\n/**\n * @param collection - A potential Foundry document collection.\n *\n * @returns Whether the given object is a Foundry document collection.\n */\nfunction isDocumentCollection(collection) {\n    return collection !== void 0 && collection !== null &&\n        collection instanceof foundry.documents.abstract.DocumentCollection;\n}\n/**\n * @param collection - A potential Foundry embedded collection.\n *\n * @returns Whether the given object is a Foundry embedded collection.\n */\nfunction isEmbeddedCollection(collection) {\n    return collection !== void 0 && collection !== null && collection instanceof foundry.abstract.EmbeddedCollection;\n}\n/**\n * @param doc - A potential Foundry folder.\n *\n * @returns Whether the given object is a Foundry folder.\n */\nfunction isFolder(doc) {\n    return doc !== void 0 && doc !== null && doc instanceof foundry.documents.Folder;\n}\n/**\n * @param doc - A potential Foundry folder class.\n *\n * @returns Whether the given object is a Foundry folder class.\n */\nfunction isFolderClass(doc) {\n    return doc !== void 0 && doc !== null && Object.prototype.isPrototypeOf.call(foundry.documents.Folder, doc);\n}\n\nexport { isDocument, isDocumentClass, isDocumentCollection, isEmbeddedCollection, isFolder, isFolderClass };\n//# sourceMappingURL=index.js.map\n", "import { tick } from 'svelte';\nimport { Hashing } from '@typhonjs-svelte/runtime-base/util';\nimport { hasPrototype, isObject, isPlainObject } from '@typhonjs-svelte/runtime-base/util/object';\nimport { isDocument, isDocumentCollection } from '@typhonjs-fvtt/types-fvtt-shim/guard';\nimport { DynMapReducer } from '@typhonjs-svelte/runtime-base/svelte/store/reducer';\n\n/**\n * Provides management of reactive embedded collections.\n *\n * @privateRemarks\n * TODO: Consider subscribing to TJSDocument rather than exposing {@link EmbeddedStoreManager.handleDocChange} and\n * {@link EmbeddedStoreManager.handleUpdate}\n */\nclass EmbeddedStoreManager {\n    /**\n     * RegExp for detecting CRUD updates for the associated document.\n     */\n    static #updateActionRegex = /(?<action>create|delete|update)(?<sep>\\.?)(?<name>\\w+)/;\n    /**\n     */\n    #name = new Map();\n    /**\n     * Source document.\n     */\n    #document;\n    /**\n     * Reverse lookup for older Foundry versions.\n     */\n    #collectionToDocName = new Map();\n    /**\n     * Valid embedded collection actions.\n     */\n    #embeddedNames = new Set();\n    /**\n     * @param document - The associated document holder.\n     */\n    constructor(document) {\n        this.#document = document;\n        this.handleDocChange();\n        Object.seal(this);\n    }\n    /**\n     * Create a reactive embedded collection store. When no options are provided the name of the embedded collection\n     * matches the document name.\n     *\n     * @param FoundryDoc - A Foundry document.\n     *\n     * @param [options] - Dynamic reducer create options.\n     *\n     * @typeParam D `Foundry Document`.\n     *\n     * @typeParam O `CreateOptions` - Embedded API create options.\n     */\n    create(FoundryDoc, options) {\n        const docName = FoundryDoc?.documentName;\n        if (typeof docName !== 'string') {\n            throw new TypeError(`EmbeddedStoreManager.create error: 'FoundryDoc' does not have a valid 'documentName' property.`);\n        }\n        const doc = this.#document[0];\n        let collection = null;\n        if (doc) {\n            try {\n                collection = doc.getEmbeddedCollection(docName);\n            }\n            catch (err) {\n                console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${docName}`);\n            }\n        }\n        let embeddedData = this.#name.get(docName);\n        if (!embeddedData) {\n            embeddedData = {\n                collection,\n                stores: new Map()\n            };\n            this.#name.set(docName, embeddedData);\n        }\n        /**\n         * Reducer name\n         */\n        let name;\n        /**\n         * Rest of common reducer options.\n         */\n        let rest = {};\n        /**\n         * Reducer constructor function.\n         */\n        let ctor;\n        if (typeof options === 'string') {\n            name = options;\n            ctor = DynMapReducer;\n        }\n        else if (typeof options === 'function' && hasPrototype(options, DynMapReducer)) {\n            ctor = options;\n        }\n        else if (isObject(options)) {\n            ({ name, ctor = DynMapReducer, ...rest } = options);\n        }\n        else {\n            name = docName;\n            ctor = DynMapReducer;\n        }\n        if (!hasPrototype(ctor, DynMapReducer)) {\n            throw new TypeError(`EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.`);\n        }\n        name = name ?? ctor?.name;\n        if (typeof name !== 'string') {\n            throw new TypeError(`EmbeddedStoreManager.create error: 'name' is not a string.`);\n        }\n        if (embeddedData.stores.has(name)) {\n            return embeddedData.stores.get(name);\n        }\n        else {\n            const reducerOptions = collection ? { data: collection, ...rest } : { ...rest };\n            const instance = new ctor(reducerOptions);\n            embeddedData.stores.set(name, instance);\n            // Invoke protected initialize method.\n            if (typeof instance?.initialize === 'function') {\n                instance.initialize(rest);\n            }\n            return instance;\n        }\n    }\n    /**\n     * Destroys one or more embedded collection reducers. When no `reducerName` is provided all reactive embedded\n     * collections are destroyed for the given document type.\n     *\n     * @param FoundryDoc - A Foundry document class constructor.\n     *\n     * @param [reducerName] - Optional name of a specific reducer to destroy.\n     *\n     * @typeParam D `Foundry Document`.\n     */\n    destroy(FoundryDoc, reducerName) {\n        let count = 0;\n        // Destroy all embedded stores\n        if (FoundryDoc === void 0) {\n            for (const embeddedData of this.#name.values()) {\n                embeddedData.collection = null;\n                for (const store of embeddedData.stores.values()) {\n                    store.destroy();\n                    count++;\n                }\n            }\n            this.#name.clear();\n        }\n        else {\n            const docName = FoundryDoc?.documentName;\n            if (typeof docName !== 'string') {\n                throw new TypeError(`EmbeddedStoreManager.delete error: 'FoundryDoc' does not have a valid 'documentName' property.`);\n            }\n            if (reducerName === void 0) {\n                const embeddedData = this.#name.get(docName);\n                if (embeddedData) {\n                    embeddedData.collection = null;\n                    for (const store of embeddedData.stores.values()) {\n                        store.destroy();\n                        count++;\n                    }\n                }\n                this.#name.delete(docName);\n            }\n            else if (reducerName === 'string') {\n                const embeddedData = this.#name.get(docName);\n                if (embeddedData) {\n                    const store = embeddedData.stores.get(reducerName);\n                    if (store) {\n                        store.destroy();\n                        count++;\n                    }\n                }\n            }\n        }\n        return count > 0;\n    }\n    /**\n     * Returns a specific existing embedded collection store. When no `reducerName` is provided the document name\n     * is used instead.\n     *\n     * @param FoundryDoc - A Foundry document class constructor.\n     *\n     * @param [reducerName] - Optional name of a specific reducer to get.\n     *\n     * @typeParam D `Foundry Document`.\n     *\n     * @returns The associated reactive embedded collection / reducer.\n     */\n    get(FoundryDoc, reducerName) {\n        const docName = FoundryDoc?.documentName;\n        if (typeof docName !== 'string') {\n            throw new TypeError(`EmbeddedStoreManager.get error: 'FoundryDoc' does not have a valid 'documentName' property.`);\n        }\n        const embeddedData = this.#name.get(docName);\n        if (embeddedData) {\n            return embeddedData.stores.get(reducerName ?? docName);\n        }\n    }\n    /**\n     * Updates all existing embedded collection stores with the associated embedded collection\n     */\n    handleDocChange() {\n        const doc = this.#document[0];\n        if (isDocument(doc)) {\n            const existingEmbeddedNames = new Set(this.#name.keys());\n            /**\n             * All embedded names from associated document.\n             */\n            const embeddedNames = Object.entries(doc.constructor?.metadata?.embedded ?? []);\n            this.#collectionToDocName.clear();\n            // Remove all previously stored embedded name CRUD keys.\n            this.#embeddedNames.clear();\n            for (const [docName, collectionName] of embeddedNames) {\n                // Remove processed embedded doc name from existingEmbeddedNames set.\n                existingEmbeddedNames.delete(docName);\n                // Update CRUD keys for v10.\n                this.#embeddedNames.add(`create${docName}`);\n                this.#embeddedNames.add(`delete${docName}`);\n                this.#embeddedNames.add(`update${docName}`);\n                // Update CRUD keys for v11.\n                this.#embeddedNames.add(`create.${collectionName}`);\n                this.#embeddedNames.add(`delete.${collectionName}`);\n                this.#embeddedNames.add(`update.${collectionName}`);\n                // Update CRUD keys for v12.\n                this.#embeddedNames.add(`create${collectionName}`);\n                this.#embeddedNames.add(`delete${collectionName}`);\n                this.#embeddedNames.add(`update${collectionName}`);\n                // v10 collection to doc name lookup.\n                this.#collectionToDocName.set(docName, docName);\n                this.#collectionToDocName.set(collectionName, docName);\n                let collection = null;\n                try {\n                    // Update any existing stores with the actual collection.\n                    collection = doc.getEmbeddedCollection(docName);\n                }\n                catch (err) {\n                    console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${docName}`);\n                }\n                // Update EmbeddedData for new collection.\n                const embeddedData = this.#name.get(docName);\n                if (embeddedData) {\n                    // A bit funky here, but Foundry collections modify the Map type.\n                    embeddedData.collection = collection;\n                    // Update all existing stores.\n                    for (const store of embeddedData.stores.values()) {\n                        store.setData(embeddedData.collection, true);\n                    }\n                }\n            }\n            // Update all existing embedded collections with null data that aren't processed above.\n            for (const embeddedName of existingEmbeddedNames) {\n                const embeddedData = this.#name.get(embeddedName);\n                if (embeddedData) {\n                    embeddedData.collection = null;\n                    for (const store of embeddedData.stores.values()) {\n                        store.setData(null, true);\n                    }\n                }\n            }\n        }\n        else // Reset all embedded reducer stores to null data.\n         {\n            this.#collectionToDocName.clear();\n            this.#embeddedNames.clear();\n            for (const embeddedData of this.#name.values()) {\n                embeddedData.collection = null;\n                for (const store of embeddedData.stores.values()) {\n                    store.setData(null, true);\n                }\n            }\n        }\n    }\n    /**\n     * Handles updates to embedded stores parsing the document update action for valid embedded store types.\n     *\n     * On create, delete, update parse the type being modified then force index updates for the embedded type.\n     *\n     * @param action - Update action from document.\n     */\n    handleUpdate(action) {\n        if (!this.#embeddedNames.has(action)) {\n            return;\n        }\n        const match = EmbeddedStoreManager.#updateActionRegex.exec(action);\n        if (match && match.groups) {\n            const docOrCollectionName = match.groups.name;\n            const embeddedName = this.#collectionToDocName.get(docOrCollectionName);\n            const embeddedData = this.#name.get(embeddedName);\n            if (embeddedData) {\n                for (const store of embeddedData.stores.values()) {\n                    store.index.update(true);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Provides a wrapper implementing the Svelte store / subscriber protocol around any Document / ClientMixinDocument.\n * This makes documents reactive in a Svelte component, but otherwise provides subscriber functionality external to\n * Svelte.\n *\n * @typeParam D `Foundry Document`.\n */\nclass TJSDocument {\n    /**\n     * Fake Application API that ClientDocumentMixin uses for document model callbacks.\n     */\n    #callbackAPI;\n    /**\n     * Wrapped document.\n     */\n    #document = [void 0];\n    /**\n     *\n     */\n    #embeddedStoreManager;\n    /**\n     *\n     */\n    #embeddedAPI;\n    /**\n     * UUIDv4 assigned to this instance.\n     */\n    #uuidv4;\n    /**\n     *\n     */\n    #options = {};\n    /**\n     * All current subscribers.\n     */\n    #subscribers = [];\n    /**\n     * Latest update options processed.\n     */\n    #updateOptions;\n    /**\n     * @param [document] - Document to wrap or TJSDocumentOptions.\n     *\n     * @param [options] - TJSDocument options.\n     */\n    constructor(document, options = {}) {\n        this.#uuidv4 = `tjs-document-${Hashing.uuidv4()}`;\n        this.#callbackAPI = {\n            close: this.#deleted.bind(this),\n            render: this.#updateSubscribers.bind(this)\n        };\n        if (isPlainObject(document)) // Handle case when only options are passed into ctor.\n         {\n            this.setOptions(document);\n        }\n        else {\n            this.setOptions(options);\n            this.set(document);\n        }\n    }\n    /**\n     * @returns {import('./types').EmbeddedAPI} Embedded store manager.\n     */\n    get embedded() {\n        if (!this.#embeddedAPI) {\n            this.#embeddedStoreManager = new EmbeddedStoreManager(this.#document);\n            this.#embeddedAPI = {\n                create: (doc, options) => this.#embeddedStoreManager.create(doc, options),\n                destroy: (doc, storeName) => this.#embeddedStoreManager.destroy(doc, storeName),\n                get: (doc, storeName) => this.#embeddedStoreManager.get(doc, storeName)\n            };\n        }\n        return this.#embeddedAPI;\n    }\n    /**\n     * @returns Returns the options passed on last update.\n     */\n    get updateOptions() {\n        return this.#updateOptions ?? { action: 'unknown', data: [] };\n    }\n    /**\n     * @returns Returns the UUIDv4 assigned to this store.\n     */\n    get uuidv4() { return this.#uuidv4; }\n    /**\n     * Register the callback API with the underlying Foundry document.\n     */\n    #callbackRegister() {\n        const doc = this.#document[0];\n        if (isDocument(doc) && isObject(doc?.apps) && !doc.apps[this.#uuidv4]) {\n            doc.apps[this.#uuidv4] = this.#callbackAPI;\n        }\n    }\n    /**\n     * Unregister the callback API with the underlying Foundry document.\n     */\n    #callbackUnregister() {\n        const doc = this.#document[0];\n        if (isDocument(doc)) {\n            delete doc?.apps?.[this.#uuidv4];\n        }\n    }\n    /**\n     * Handles cleanup when the document is deleted. Invoking any optional delete function set in the constructor.\n     *\n     * @returns Promise when completed.\n     */\n    async #deleted() {\n        const doc = this.#document[0];\n        // Check to see if the document is still in the associated collection to determine if actually deleted.\n        if (isDocument(doc) && !doc?.collection?.has(doc.id)) {\n            this.#setDocument(void 0);\n            if (typeof this.#options.preDelete === 'function') {\n                await this.#options.preDelete(doc);\n            }\n            this.#updateSubscribers(false, { action: 'delete' });\n            if (typeof this.#options.delete === 'function') {\n                await this.#options.delete(doc);\n            }\n            // Allow subscribers to be able to query `updateOptions` involving any reactive statements.\n            await tick();\n            this.#updateOptions = void 0;\n        }\n    }\n    /**\n     * Completely removes all internal subscribers, any optional delete callback, and unregisters from the\n     * ClientDocumentMixin `apps` tracking object.\n     */\n    destroy() {\n        if (this.#embeddedStoreManager) {\n            this.#embeddedStoreManager.destroy();\n            this.#embeddedStoreManager = void 0;\n            this.#embeddedAPI = void 0;\n        }\n        this.#setDocument(void 0);\n        this.#options.delete = void 0;\n        this.#options.preDelete = void 0;\n        this.#subscribers.length = 0;\n    }\n    /**\n     * @returns Current document\n     */\n    get() { return this.#document[0]; }\n    /**\n     * Attempts to create a Foundry UUID from standard drop data. This may not work for all systems.\n     *\n     * @param data - Drop transfer data.\n     *\n     * @param [opts] - Optional parameters.\n     *\n     * @param [opts.compendium=true] - Accept compendium documents.\n     *\n     * @param [opts.world=true] - Accept world documents.\n     *\n     * @param [opts.types] - Require the `data.type` to match entry in `types`.\n     *\n     * @returns Foundry UUID for drop data.\n     */\n    static getUUIDFromDataTransfer(data, { compendium = true, world = true, types = void 0 } = {}) {\n        if (!isObject(data)) {\n            return void 0;\n        }\n        if (Array.isArray(types) && !types.includes(data.type)) {\n            return void 0;\n        }\n        let uuid = void 0;\n        if (typeof data.uuid === 'string') // v10 and above provides a full UUID.\n         {\n            const isCompendium = data.uuid.startsWith('Compendium');\n            if (isCompendium && compendium) {\n                uuid = data.uuid;\n            }\n            else if (world) {\n                uuid = data.uuid;\n            }\n        }\n        return uuid;\n    }\n    /**\n     * Sets a new document target to be monitored. To unset use `undefined` or `null`.\n     *\n     * @param doc - New document to set.\n     *\n     * @param [options] - New document update options to set.\n     */\n    set(doc, options = {}) {\n        if (doc !== void 0 && doc !== null && !isDocument(doc)) {\n            throw new TypeError(`TJSDocument set error: 'document' is not a valid Document or undefined / null.`);\n        }\n        if (!isObject(options)) {\n            throw new TypeError(`TJSDocument set error: 'options' is not an object.`);\n        }\n        // Only post an update if the document has changed.\n        if (this.#setDocument(doc)) {\n            // Only add registration if there are current subscribers.\n            if (isDocument(doc) && this.#subscribers.length) {\n                this.#callbackRegister();\n            }\n            this.#updateSubscribers(false, {\n                ...options,\n                action: `tjs-set-${doc === void 0 || doc === null ? 'undefined' : 'new'}`\n            });\n        }\n    }\n    /**\n     * Internally sets the new document being tracked.\n     *\n     * @param doc -\n     *\n     * @returns {boolean} Whether the document changed.\n     */\n    #setDocument(doc) {\n        const changed = doc !== this.#document[0];\n        // Unregister before setting new document state.\n        if (changed) {\n            this.#callbackUnregister();\n        }\n        this.#document[0] = doc === void 0 || doc === null ? void 0 : doc;\n        if (changed && this.#embeddedStoreManager) {\n            this.#embeddedStoreManager.handleDocChange();\n        }\n        return changed;\n    }\n    /**\n     * Potentially sets new document from data transfer object.\n     *\n     * @param data - Document transfer data.\n     *\n     * @param [options] - Optional parameters for {@link TJSDocument.getUUIDFromDataTransfer}.\n     *\n     * @returns Returns true if new document set from data transfer blob.\n     */\n    async setFromDataTransfer(data, options) {\n        return this.setFromUUID(TJSDocument.getUUIDFromDataTransfer(data, options));\n    }\n    /**\n     * Sets the document by Foundry UUID performing a lookup and setting the document if found.\n     *\n     * @param {string}   uuid - A Foundry UUID to lookup.\n     *\n     * @param {import('./types').TJSDocumentUpdateOptions}   [options] - New document update options to set.\n     *\n     * @returns {Promise<boolean>} True if successfully set document from UUID.\n     */\n    async setFromUUID(uuid, options) {\n        if (typeof uuid !== 'string' || uuid.length === 0) {\n            return false;\n        }\n        try {\n            const doc = await globalThis.fromUuid(uuid);\n            if (doc) {\n                this.set(doc, options);\n                return true;\n            }\n        }\n        catch (err) { /**/ }\n        return false;\n    }\n    /**\n     * Sets options for this document wrapper / store.\n     *\n     * @param options - Options for TJSDocument.\n     */\n    setOptions(options) {\n        if (!isObject(options)) {\n            throw new TypeError(`TJSDocument error: 'options' is not a plain object.`);\n        }\n        // Verify valid values -------------\n        if (options.delete !== void 0 && options.delete !== null && typeof options.delete !== 'function') {\n            throw new TypeError(`TJSDocument error: 'delete' attribute in options is not a function or null.`);\n        }\n        if (options.preDelete !== void 0 && options.preDelete !== null && typeof options.preDelete !== 'function') {\n            throw new TypeError(`TJSDocument error: 'preDelete' attribute in options is not a function or null.`);\n        }\n        // Set any valid values -------------\n        if (options.delete !== void 0) {\n            this.#options.delete = options.delete ?? void 0;\n        }\n        if (options.preDelete !== void 0) {\n            this.#options.preDelete = options.preDelete ?? void 0;\n        }\n    }\n    /**\n     * @param handler - Callback function that is invoked on update / changes.\n     *\n     * @returns Unsubscribe function.\n     */\n    subscribe(handler) {\n        let addedSubscriber = false;\n        const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n        if (currentIdx === -1) {\n            this.#subscribers.push(handler);\n            addedSubscriber = true;\n        }\n        if (addedSubscriber) {\n            // Register callback with first subscriber.\n            if (this.#subscribers.length === 1) {\n                this.#callbackRegister();\n            }\n            const updateOptions = { action: 'tjs-subscribe', data: [] };\n            handler(this.#document[0], updateOptions); // Call handler with current value and update options.\n        }\n        // Return unsubscribe function.\n        return () => {\n            const index = this.#subscribers.findIndex((sub) => sub === handler);\n            if (index !== -1) {\n                this.#subscribers.splice(index, 1);\n            }\n            // Unsubscribe from document callback if there are no subscribers.\n            if (this.#subscribers.length === 0) {\n                this.#callbackUnregister();\n            }\n        };\n    }\n    /**\n     * @param [force] - unused - signature from Foundry render function.\n     *\n     * @param [options] - Options from render call; will have document update context.\n     */\n    #updateSubscribers(force, options = {}) {\n        // Shallow copy w/ remapped keys.\n        const optionsRemap = {\n            action: (options.action ?? options.renderContext ?? 'tjs-unknown'),\n            data: (options.data ?? options.renderData ?? [])\n        };\n        // Coerce `data` as necessary into an array to standardize receiving processing.\n        if (!Array.isArray(optionsRemap.data)) {\n            optionsRemap.data = [optionsRemap.data];\n        }\n        this.#updateOptions = optionsRemap;\n        const subscribers = this.#subscribers;\n        const doc = this.#document[0];\n        for (let cntr = 0; cntr < subscribers.length; cntr++) {\n            subscribers[cntr](doc, optionsRemap);\n        }\n        if (this.#embeddedStoreManager) {\n            this.#embeddedStoreManager.handleUpdate(optionsRemap.action);\n        }\n    }\n}\n\n/**\n * Provides a wrapper implementing the Svelte store / subscriber protocol around any DocumentCollection. This makes\n * document collections reactive in a Svelte component, but otherwise provides subscriber functionality external to\n * Svelte.\n *\n * @typeParam C `Foundry Collection`.\n */\nclass TJSDocumentCollection {\n    /**\n     * Fake Application API that DocumentCollection uses for document model callbacks.\n     */\n    #callbackAPI;\n    /**\n     * Collection being wrapped.\n     */\n    #collection = void 0;\n    /**\n     * UUIDv4 to associate as key with wrapped collection.\n     */\n    #uuidv4;\n    /**\n     * Configuration options.\n     */\n    #options = {};\n    /**\n     * All current subscribers.\n     */\n    #subscribers = [];\n    /**\n     * Latest update options processed.\n     */\n    #updateOptions;\n    /**\n     * @param [collection] - Collection to wrap or TJSDocumentCollectionOptions.\n     *\n     * @param [options] - TJSDocumentCollection options.\n     */\n    constructor(collection, options = {}) {\n        this.#uuidv4 = `tjs-collection-${Hashing.uuidv4()}`;\n        this.#callbackAPI = {\n            uuid: this.#uuidv4,\n            close: this.#deleted.bind(this),\n            render: this.#updateSubscribers.bind(this)\n        };\n        if (isPlainObject(collection)) // Handle case when only options are passed into ctor.\n         {\n            this.setOptions(collection);\n        }\n        else {\n            this.setOptions(options);\n            this.set(collection);\n        }\n    }\n    /**\n     * Returns the options passed on last update.\n     *\n     * @returns Last update options.\n     */\n    get updateOptions() {\n        return this.#updateOptions ?? { action: 'unknown', data: [] };\n    }\n    /**\n     * Returns the UUIDv4 assigned to this store.\n     *\n     * @returns UUIDv4\n     */\n    get uuid() { return this.#uuidv4; }\n    /**\n     * Register the callback API with the underlying Foundry collection.\n     */\n    #callbackRegister() {\n        const collection = this.#collection;\n        if (isDocumentCollection(collection) && Array.isArray(collection?.apps)) {\n            const index = collection.apps.findIndex((sub) => sub === this.#callbackAPI);\n            if (index === -1) {\n                collection.apps.push(this.#callbackAPI);\n            }\n        }\n    }\n    /**\n     * Unregister the callback API with the underlying Foundry collection.\n     */\n    #callbackUnregister() {\n        const collection = this.#collection;\n        if (isDocumentCollection(this.#collection) && Array.isArray(collection?.apps)) {\n            const index = collection.apps.findIndex((sub) => sub === this.#callbackAPI);\n            if (index >= 0) {\n                collection.apps.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Handles cleanup when the collection is deleted. Invoking any optional delete function set in the constructor.\n     *\n     * @returns {Promise<void>}\n     */\n    async #deleted() {\n        const collection = this.#collection;\n        this.#callbackUnregister();\n        this.#collection = void 0;\n        // Only invoke handlers and subscribers if the collection was defined.\n        if (collection) {\n            if (typeof this.#options.preDelete === 'function') {\n                await this.#options.preDelete(collection);\n            }\n            this.#updateSubscribers(false, { action: 'delete' });\n            if (typeof this.#options.delete === 'function') {\n                await this.#options.delete(collection);\n            }\n        }\n        // Allow subscribers to be able to query `updateOptions` involving any reactive statements.\n        await tick();\n        this.#updateOptions = void 0;\n    }\n    /**\n     * Completely removes all internal subscribers, any optional delete callback, and unregisters from the\n     * DocumentCollection `apps` tracking array.\n     */\n    destroy() {\n        this.#callbackUnregister();\n        this.#collection = void 0;\n        this.#options.delete = void 0;\n        this.#options.preDelete = void 0;\n        this.#subscribers.length = 0;\n    }\n    /**\n     * @returns Current collection if any.\n     */\n    get() { return this.#collection; }\n    /**\n     * Sets a new document collection target to be monitored. To unset use `undefined` or `null`.\n     *\n     * @param collection - New collection to set.\n     *\n     * @param [options] - New collection update options to set.\n     */\n    set(collection, options = {}) {\n        if (collection !== void 0 && collection !== null && !isDocumentCollection(collection)) {\n            throw new TypeError(`TJSDocumentCollection set error: 'collection' is not a valid DocumentCollection or undefined.`);\n        }\n        if (!isObject(options)) {\n            throw new TypeError(`TJSDocument set error: 'options' is not an object.`);\n        }\n        const changed = this.#collection !== collection;\n        if (changed) {\n            this.#callbackUnregister();\n        }\n        this.#collection = collection === void 0 || collection === null ? void 0 : collection;\n        if (changed) {\n            if (isDocumentCollection(collection) && this.#subscribers.length) {\n                this.#callbackRegister();\n            }\n            this.#updateSubscribers(false, {\n                data: [],\n                ...options,\n                action: `tjs-set-${collection === void 0 || collection === null ? 'undefined' : 'new'}`\n            });\n        }\n    }\n    /**\n     * Sets options for this collection wrapper / store.\n     *\n     * @param options - Options for TJSDocumentCollection.\n     */\n    setOptions(options) {\n        if (!isObject(options)) {\n            throw new TypeError(`TJSDocumentCollection error: 'options' is not an object.`);\n        }\n        // Verify valid values -------------\n        if (options.delete !== void 0 && options.delete !== null && typeof options.delete !== 'function') {\n            throw new TypeError(`TJSDocumentCollection error: 'delete' attribute in options is not a function or null.`);\n        }\n        if (options.preDelete !== void 0 && options.preDelete !== null && typeof options.preDelete !== 'function') {\n            throw new TypeError(`TJSDocumentCollection error: 'preDelete' attribute in options is not a function or null.`);\n        }\n        // Set any valid values -------------\n        if (options.delete !== void 0) {\n            this.#options.delete = options.delete ?? void 0;\n        }\n        if (options.preDelete !== void 0) {\n            this.#options.preDelete = options.delete ?? void 0;\n        }\n    }\n    /**\n     * @param handler - Callback function that is invoked on update / changes.\n     *\n     * @returns Unsubscribe function.\n     */\n    subscribe(handler) {\n        let addedSubscriber = false;\n        const currentIdx = this.#subscribers.findIndex((entry) => entry === handler);\n        if (currentIdx === -1) {\n            this.#subscribers.push(handler);\n            addedSubscriber = true;\n        }\n        if (addedSubscriber) {\n            // Register callback with first subscriber.\n            if (this.#subscribers.length === 1) {\n                this.#callbackRegister();\n            }\n            const collection = this.#collection;\n            const updateOptions = { action: 'tjs-subscribe', data: [] };\n            handler(collection, updateOptions); // Call handler with current value and update options.\n        }\n        // Return unsubscribe function.\n        return () => {\n            const index = this.#subscribers.findIndex((sub) => sub === handler);\n            if (index !== -1) {\n                this.#subscribers.splice(index, 1);\n            }\n            // Unsubscribe from collection if there are no subscribers.\n            if (this.#subscribers.length === 0) {\n                this.#callbackUnregister();\n            }\n        };\n    }\n    /**\n     * @param force - unused - signature from Foundry render function.\n     *\n     * @param [options] - Options from render call; will have collection update context.\n     */\n    #updateSubscribers(force, options = {}) {\n        // Shallow copy w/ remapped keys.\n        const optionsRemap = {\n            action: (options.action ?? options.renderContext ?? 'tjs-unknown'),\n            data: (options.data ?? options.renderData ?? [])\n        };\n        // Coerce `data` as necessary into an array to standardize receiving processing.\n        if (!Array.isArray(optionsRemap.data)) {\n            optionsRemap.data = [optionsRemap.data];\n        }\n        this.#updateOptions = optionsRemap;\n        const subscribers = this.#subscribers;\n        const collection = this.#collection;\n        for (let cntr = 0; cntr < subscribers.length; cntr++) {\n            subscribers[cntr](collection, optionsRemap);\n        }\n    }\n}\n\nexport { TJSDocument, TJSDocumentCollection };\n//# sourceMappingURL=index.js.map\n"],
  "mappings": "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",
  "names": ["filters", "filters"]
}
