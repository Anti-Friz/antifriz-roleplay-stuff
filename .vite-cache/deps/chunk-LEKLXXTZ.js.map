{
  "version": 3,
  "sources": ["../../../../../../program/Javascript/projects/TyphonJS/typhonjs-svelte/runtime-base/_dist/util/browser/index.js"],
  "sourcesContent": ["import { Frozen } from '@typhonjs-svelte/runtime-base/util';\nimport { isObject } from '@typhonjs-svelte/runtime-base/util/object';\n\n/**\n * Provides cross-realm checks for DOM nodes / elements, events, and essential duck typing for any class-based object\n * with a constructor name. The impetus is that certain browsers such as Chrome and Firefox behave differently when\n * performing `instanceof` checks when elements are moved between browser windows. With Firefox in particular, the\n * entire JS runtime cannot use `instanceof` checks as the instances of fundamental DOM elements differ between\n * windows.\n *\n * TRL supports moving applications from a main central browser window and popping them out into separate standalone\n * app instances in a separate browser window. In this case, for essential DOM element and event checks, it is necessary\n * to employ the workarounds found in `CrossWindow`.\n */\nclass CrossWindow {\n    /**\n     * @private\n     */\n    constructor() {\n        throw new Error('CrossWindow constructor: This is a static class and should not be constructed.');\n    }\n    /**\n     * Class names for all focusable element types.\n     */\n    static #FocusableElementClassNames = ['HTMLAnchorElement', 'HTMLButtonElement', 'HTMLDetailsElement',\n        'HTMLEmbedElement', 'HTMLIFrameElement', 'HTMLInputElement', 'HTMLObjectElement', 'HTMLSelectElement',\n        'HTMLTextAreaElement'];\n    /**\n     * DOM nodes with defined `ownerDocument` property.\n     */\n    static #NodesWithOwnerDocument = new Set([Node.ELEMENT_NODE, Node.TEXT_NODE, Node.COMMENT_NODE,\n        Node.DOCUMENT_FRAGMENT_NODE]);\n    // Various UIEvent sets for duck typing by constructor name.\n    /**\n     * Duck typing class names for pointer events.\n     */\n    static #PointerEventSet = new Set(['MouseEvent', 'PointerEvent']);\n    /**\n     * Duck typing class names for all UIEvents.\n     */\n    static #UIEventSet = new Set(['UIEvent', 'FocusEvent', 'MouseEvent', 'WheelEvent', 'KeyboardEvent', 'PointerEvent',\n        'TouchEvent', 'InputEvent', 'CompositionEvent', 'DragEvent']);\n    /**\n     * Duck typing class names for events considered as user input.\n     */\n    static #UserInputEventSet = new Set(['KeyboardEvent', 'MouseEvent', 'PointerEvent']);\n    /**\n     * Internal options used by `#checkDOMInstanceType` when retrieving the Window reference from a Node that doesn't\n     * define `ownerDocument`.\n     */\n    static #optionsInternalCheckDOM = { throws: false };\n    // DOM Querying ---------------------------------------------------------------------------------------------------\n    /**\n     * Convenience method to test if the given target element is the current active element.\n     *\n     * @param target - Element to test as current active element.\n     */\n    static isActiveElement(target) {\n        // Duck type if target has known defined `ownerDocument` property.\n        if (this.#hasOwnerDocument(target)) {\n            return target?.ownerDocument?.activeElement === target;\n        }\n        return false;\n    }\n    /**\n     * Convenience method to retrieve the `document.activeElement` value in the current Window context of a DOM Node /\n     * Element, EventTarget, Document, or Window.\n     *\n     * @param target - DOM Node / Element, EventTarget, Document, UIEvent or Window to query.\n     *\n     * @param [options] - Options.\n     *\n     * @returns Active element or `undefined` when `throws` option is `false` and the target is invalid.\n     *\n     * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n     */\n    static getActiveElement(target, { throws = true } = {}) {\n        // Duck type if target has known defined `ownerDocument` property.\n        if (this.#hasOwnerDocument(target)) {\n            return target?.ownerDocument?.activeElement ?? null;\n        }\n        // Duck type if target is a UIEvent.\n        if (this.isUIEvent(target) && isObject(target?.view)) {\n            return target?.view?.document?.activeElement ?? null;\n        }\n        // Duck type if target is a Document.\n        if (this.isDocument(target)) {\n            return target?.activeElement ?? null;\n        }\n        // Duck type if target is a Window.\n        if (this.isWindow(target)) {\n            return target?.document?.activeElement ?? null;\n        }\n        if (throws) {\n            throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`);\n        }\n        return void 0;\n    }\n    /**\n     * Convenience method to retrieve the `Document` value in the current context of a DOM Node / Element, EventTarget,\n     * Document, UIEvent, or Window.\n     *\n     * @param target - DOM Node / Element, EventTarget, Document, UIEvent or Window to query.\n     *\n     * @param [options] - Options.\n     *\n     * @returns {Document} Active document or `undefined` when `throws` option is `false` and the target is invalid.\n     *\n     * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n     */\n    static getDocument(target, { throws = true } = {}) {\n        // Duck type if target has known defined `ownerDocument` property.\n        if (this.#hasOwnerDocument(target)) {\n            return target?.ownerDocument;\n        }\n        // Duck type if target is a UIEvent.\n        if (this.isUIEvent(target) && isObject(target?.view)) {\n            return target?.view?.document;\n        }\n        // Duck type if target is a Document.\n        if (this.isDocument(target)) {\n            return target;\n        }\n        // Duck type if target is a Window.\n        if (this.isWindow(target)) {\n            return target?.document;\n        }\n        if (throws) {\n            throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`);\n        }\n        return void 0;\n    }\n    /**\n     * Convenience method to retrieve the `Window` value in the current context of a DOM Node / Element, EventTarget,\n     * Document, or Window.\n     *\n     * @param target - DOM Node / Element, EventTarget, Document, UIEvent or Window to query.\n     *\n     * @param [options] - Options.\n     *\n     * @returns Active window or `undefined` when `throws` option is `false` and the target is invalid.\n     *\n     * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n     */\n    static getWindow(target, { throws = true } = {}) {\n        // Duck type if target has known defined `ownerDocument` property.\n        if (this.#hasOwnerDocument(target)) {\n            return target.ownerDocument?.defaultView ?? globalThis;\n        }\n        // Duck type if target is a UIEvent.\n        if (this.isUIEvent(target) && isObject(target?.view)) {\n            return target.view ?? globalThis;\n        }\n        // Duck type if target is a Document.\n        if (this.isDocument(target)) {\n            return target.defaultView ?? globalThis;\n        }\n        // Duck type if target is a Window.\n        if (this.isWindow(target)) {\n            return target;\n        }\n        if (throws) {\n            throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`);\n        }\n        return void 0;\n    }\n    // ES / Browser API basic prototype tests -------------------------------------------------------------------------\n    /**\n     * Provides basic prototype string type checking if `target` is a CSSImportRule.\n     *\n     * @param target - A potential CSSImportRule to test.\n     *\n     * @returns Is `target` a CSSImportRule.\n     */\n    static isCSSImportRule(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object CSSImportRule]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a CSSLayerBlockRule.\n     *\n     * @param target - A potential CSSLayerBlockRule to test.\n     *\n     * @returns Is `target` a CSSLayerBlockRule.\n     */\n    static isCSSLayerBlockRule(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object CSSLayerBlockRule]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a CSSStyleRule.\n     *\n     * @param target - A potential CSSStyleRule to test.\n     *\n     * @returns Is `target` a CSSStyleRule.\n     */\n    static isCSSStyleRule(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object CSSStyleRule]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a CSSStyleSheet.\n     *\n     * @param target - A potential CSSStyleSheet to test.\n     *\n     * @returns Is `target` a CSSStyleSheet.\n     */\n    static isCSSStyleSheet(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object CSSStyleSheet]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a Document.\n     *\n     * @param target - A potential Document to test.\n     *\n     * @returns Is `target` a Document.\n     */\n    static isDocument(target) {\n        // Match any DOM Document object by its default @@toStringTag.\n        // - HTMLDocument (`[object HTMLDocument]` in modern browsers & JSDOM)\n        // - generic Document (`[object Document]` in older or XML contexts)\n        return isObject(target) && /^\\[object (HTML)?Document]$/.test(Object.prototype.toString.call(target));\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a Map.\n     *\n     * @param target - A potential Map to test.\n     *\n     * @returns Is `target` a Map.\n     */\n    static isMap(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object Map]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a Promise.\n     *\n     * @param target - A potential Promise to test.\n     *\n     * @returns Is `target` a Promise.\n     */\n    static isPromise(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object Promise]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a RegExp.\n     *\n     * @param target - A potential RegExp to test.\n     *\n     * @returns Is `target` a RegExp.\n     */\n    static isRegExp(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object RegExp]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a Set.\n     *\n     * @param target - A potential Set to test.\n     *\n     * @returns Is `target` a Set.\n     */\n    static isSet(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object Set]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a URL.\n     *\n     * @param target - A potential URL to test.\n     *\n     * @returns Is `target` a URL.\n     */\n    static isURL(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object URL]';\n    }\n    /**\n     * Provides basic prototype string type checking if `target` is a Window.\n     *\n     * @param target - A potential Window to test.\n     *\n     * @returns Is `target` a Window.\n     */\n    static isWindow(target) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object Window]';\n    }\n    // DOM Element typing ---------------------------------------------------------------------------------------------\n    /**\n     * Ensures that the given target is an `instanceof` all known DOM elements that are focusable. Please note that\n     * additional checks are required regarding focusable state; use {@link A11yHelper.isFocusable} for a complete check.\n     *\n     * @param target - Target to test for `instanceof` focusable HTML element.\n     *\n     * @returns Is target an `instanceof` a focusable DOM element.\n     */\n    static isFocusableHTMLElement(target) {\n        for (let cntr = this.#FocusableElementClassNames.length; --cntr >= 0;) {\n            if (this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, this.#FocusableElementClassNames[cntr])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Provides precise type checking if `target` is a DocumentFragment.\n     *\n     * @param target - A potential DocumentFragment to test.\n     *\n     * @returns Is `target` a DocumentFragment.\n     */\n    static isDocumentFragment(target) {\n        return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, 'DocumentFragment');\n    }\n    /**\n     * Provides precise type checking if `target` is an Element.\n     *\n     * @param target - A potential Element to test.\n     *\n     * @returns Is `target` an Element.\n     */\n    static isElement(target) {\n        return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'Element');\n    }\n    /**\n     * Provides precise type checking if `target` is a HTMLAnchorElement.\n     *\n     * @param target - A potential HTMLAnchorElement to test.\n     *\n     * @returns Is `target` a HTMLAnchorElement.\n     */\n    static isHTMLAnchorElement(target) {\n        return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'HTMLAnchorElement');\n    }\n    /**\n     * Provides precise type checking if `target` is an HTMLElement.\n     *\n     * @param target - A potential HTMLElement to test.\n     *\n     * @returns Is `target` a HTMLElement.\n     */\n    static isHTMLElement(target) {\n        return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'HTMLElement');\n    }\n    /**\n     * Provides precise type checking if `target` is a Node.\n     *\n     * @param target - A potential Node to test.\n     *\n     * @returns Is `target` a DOM Node.\n     */\n    static isNode(target) {\n        if (typeof target?.nodeType !== 'number') {\n            return false;\n        }\n        if (target instanceof globalThis.Node) {\n            return true;\n        }\n        // Must retrieve the window by a more thorough duck type via `getWindow` as not all Nodes have `ownerDocument`\n        // defined.\n        const activeWindow = this.getWindow(target, this.#optionsInternalCheckDOM);\n        const TargetNode = activeWindow?.Node;\n        return TargetNode && target instanceof TargetNode;\n    }\n    /**\n     * Provides precise type checking if `target` is a ShadowRoot.\n     *\n     * @param target - A potential ShadowRoot to test.\n     *\n     * @returns Is `target` a ShadowRoot.\n     */\n    static isShadowRoot(target) {\n        // ShadowRoot is a specialized type of DocumentFragment.\n        return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, 'ShadowRoot');\n    }\n    /**\n     * Provides precise type checking if `target` is a SVGElement.\n     *\n     * @param target - A potential SVGElement to test.\n     *\n     * @returns Is `target` a SVGElement.\n     */\n    static isSVGElement(target) {\n        return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'SVGElement');\n    }\n    // Event typing ---------------------------------------------------------------------------------------------------\n    /**\n     * Provides basic duck type checking for `Event` signature and optional constructor name(s).\n     *\n     * @param target - A potential DOM event to test.\n     *\n     * @param [types] Specific constructor name or Set of constructor names to match.\n     *\n     * @returns Is `target` an Event with optional constructor name check.\n     */\n    static isEvent(target, types) {\n        if (typeof target?.type !== 'string' || typeof target?.defaultPrevented !== 'boolean' ||\n            typeof target?.stopPropagation !== 'function') {\n            return false;\n        }\n        return types !== void 0 ? this.isCtorName(target, types) : true;\n    }\n    /**\n     * Provides basic duck type checking for `Event` signature for standard mouse / pointer events including\n     * `MouseEvent` and `PointerEvent`.\n     *\n     * @param target - A potential DOM event to test.\n     *\n     * @returns Is `target` a MouseEvent or PointerEvent.\n     */\n    static isPointerEvent(target) {\n        return this.isEvent(target, this.#PointerEventSet);\n    }\n    /**\n     * Provides basic duck type checking for `Event` signature for all UI events.\n     *\n     * @param target - A potential DOM event to test.\n     *\n     * @returns Is `target` a UIEvent.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent\n     */\n    static isUIEvent(target) {\n        return this.isEvent(target, this.#UIEventSet);\n    }\n    /**\n     * Provides basic duck type checking for `Event` signature for standard user input events including `KeyboardEvent`,\n     * `MouseEvent`, and `PointerEvent`.\n     *\n     * @param target - A potential DOM event to test.\n     *\n     * @returns Is `target` a Keyboard, MouseEvent, or PointerEvent.\n     */\n    static isUserInputEvent(target) {\n        return this.isEvent(target, this.#UserInputEventSet);\n    }\n    // Generic typing -------------------------------------------------------------------------------------------------\n    /**\n     * Provides basic type checking by constructor name(s) for objects. This can be useful when checking multiple\n     * constructor names against a provided Set.\n     *\n     * @param target - Object to test for constructor name.\n     *\n     * @param types Specific constructor name or Set of constructor names to match.\n     *\n     * @returns Does the provided object constructor name match the types provided.\n     */\n    static isCtorName(target, types) {\n        if (!isObject(target)) {\n            return false;\n        }\n        if (typeof types === 'string' && target?.constructor?.name === types) {\n            return true;\n        }\n        return !!types?.has(target?.constructor?.name);\n    }\n    // Errors ---------------------------------------------------------------------------------------------------------\n    /**\n     * Provides basic duck type checking and error name for {@link DOMException}.\n     *\n     * @param target - Error to duck type test.\n     *\n     * @param name - Specific error name.\n     *\n     * @returns Is target a DOMException matching the error name.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMException#error_names\n     */\n    static isDOMException(target, name) {\n        return isObject(target) && Object.prototype.toString.call(target) === '[object DOMException]' &&\n            target.name === name;\n    }\n    // Internal implementation ----------------------------------------------------------------------------------------\n    /**\n     * Internal generic DOM `instanceof` check. First will attempt to find the class name by `globalThis` falling back\n     * to the {@link Window} associated with the DOM node.\n     *\n     * @param target - Target to test.\n     *\n     * @param nodeType - Node type constant.\n     *\n     * @param className - DOM classname for instanceof check.\n     *\n     * @returns Is the target the given nodeType and instance of class name.\n     */\n    static #checkDOMInstanceType(target, nodeType, className) {\n        if (!isObject(target)) {\n            return false;\n        }\n        if (target.nodeType !== nodeType) {\n            return false;\n        }\n        const GlobalClass = window[className];\n        if (GlobalClass && target instanceof GlobalClass) {\n            return true;\n        }\n        const activeWindow = this.#hasOwnerDocument(target) ?\n            target?.ownerDocument?.defaultView :\n            // @ts-ignore: Safe in this context.\n            this.getWindow(target, this.#optionsInternalCheckDOM);\n        const TargetClass = activeWindow?.[className];\n        return TargetClass && target instanceof TargetClass;\n    }\n    static #hasOwnerDocument(target) {\n        return typeof target === 'object' && target !== null &&\n            this.#NodesWithOwnerDocument.has(target?.nodeType);\n    }\n}\n\n/**\n * Provides a utility function to parse / construct fully qualified URL instances from a URL string.\n */\nclass URLParser {\n    /**\n     * @private\n     */\n    constructor() {\n        throw new Error('URLParser constructor: This is a static class and should not be constructed.');\n    }\n    /**\n     * Parses a URL string converting it to a fully qualified URL. If URL is an existing URL instance, it is returned\n     * immediately. Optionally, you may construct a fully qualified URL from a relative base origin / path or with a\n     * route prefix added to the current location origin.\n     *\n     * @param options - Options.\n     *\n     * @param options.url - URL string to convert to a URL.\n     *\n     * @param [options.base] - Optional fully qualified base path for relative URL construction.\n     *\n     * @param [options.routePrefix] - Optional route prefix to add to location origin for absolute URL strings\n     *        when `base` is not defined.\n     *\n     * @returns Parsed URL or null if `url` is not parsed.\n     */\n    static parse({ url, base, routePrefix }) {\n        if (CrossWindow.isURL(url)) {\n            return url;\n        }\n        if (typeof url !== 'string') {\n            return null;\n        }\n        if (base !== void 0 && typeof base !== 'string') {\n            return null;\n        }\n        if (routePrefix !== void 0 && typeof routePrefix !== 'string') {\n            return null;\n        }\n        const targetURL = this.#createURL(url);\n        // Parse and return already fully qualified `url` string.\n        if (targetURL) {\n            return targetURL;\n        }\n        let targetBase;\n        // Parse relative url string.\n        if (url.startsWith('./') || url.startsWith('../')) {\n            // Relative from provided `base` or current path.\n            targetBase = base ? base : `${globalThis.location.origin}${globalThis.location.pathname}`;\n        }\n        else {\n            let targetRoutePrefix = '';\n            // Relative to current origin, but include any defined route prefix.\n            if (routePrefix) {\n                // Ensure route prefix starts and ends with `/` for proper URL parsing.\n                targetRoutePrefix = routePrefix.startsWith('/') ? routePrefix : `/${routePrefix}`;\n                targetRoutePrefix = targetRoutePrefix.endsWith('/') ? targetRoutePrefix : `${targetRoutePrefix}/`;\n            }\n            targetBase = `${globalThis.location.origin}${targetRoutePrefix}`;\n        }\n        return this.#createURL(url, targetBase);\n    }\n    // Internal implementation ----------------------------------------------------------------------------------------\n    /**\n     * Helper to create a URL and catch any exception. Useful until `URL.parse` and `URL.canParse` are more widespread.\n     *\n     * @param url - URL string.\n     *\n     * @param base - Base origin / path.\n     *\n     * @returns Valid URL or null.\n     */\n    static #createURL(url, base = '') {\n        try {\n            return new URL(url, base);\n        }\n        catch (err) {\n            return null;\n        }\n    }\n}\n\n/**\n * Provides a utility to validate media file types and determine the appropriate HTML element type for rendering.\n */\nclass AssetValidator {\n    /** Default media types. */\n    static #mediaTypes = Object.freeze({\n        all: Frozen.Set(['audio', 'img', 'svg', 'video']),\n        audio: Frozen.Set(['audio']),\n        img: Frozen.Set(['img']),\n        img_svg: Frozen.Set(['img', 'svg']),\n        img_svg_video: Frozen.Set(['img', 'svg', 'video']),\n        video: Frozen.Set(['video']),\n    });\n    /** Supported audio extensions. */\n    static #audioExtensions = new Set(['mp3', 'wav', 'ogg', 'aac', 'flac', 'webm']);\n    /** Supported image extensions. */\n    static #imageExtensions = new Set(['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp']);\n    /** Supported SVG extensions. */\n    static #svgExtensions = new Set(['svg']);\n    /** Supported video extensions. */\n    static #videoExtensions = new Set(['mp4', 'webm', 'ogg']);\n    /**\n     * @private\n     */\n    constructor() {\n        throw new Error('AssetValidator constructor: This is a static class and should not be constructed.');\n    }\n    /**\n     * Provides several readonly default media type Sets useful for the `mediaTypes` option.\n     */\n    static get MediaTypes() {\n        return this.#mediaTypes;\n    }\n    /**\n     * Parses the provided file path to determine the media type and validity based on the file extension. Certain\n     * extensions can be excluded in addition to filtering by specified media types.\n     *\n     * @param options - Options.\n     *\n     * @returns The parsed asset information containing the file path, extension, element type, and whether the parsing\n     *          is valid for the file extension is supported and not excluded.\n     *\n     * @throws {TypeError} If the provided `url` is not a string or URL, `routePrefix` is not a string,\n     *         `exclude` is not a Set, or `mediaTypes` is not a Set.\n     */\n    static parseMedia({ url, routePrefix, exclude, mediaTypes = this.#mediaTypes.all, raiseException = false }) {\n        const throws = typeof raiseException === 'boolean' ? raiseException : true;\n        if (typeof url !== 'string' && !CrossWindow.isURL(url)) {\n            if (throws) {\n                throw new TypeError(`'url' is not a string or URL instance.`);\n            }\n            else {\n                return { url, valid: false };\n            }\n        }\n        if (routePrefix !== void 0 && typeof routePrefix !== 'string') {\n            if (throws) {\n                throw new TypeError(`'routePrefix' is not a string.`);\n            }\n            else {\n                return { url, valid: false };\n            }\n        }\n        if (exclude !== void 0 && !CrossWindow.isSet(exclude)) {\n            if (throws) {\n                throw new TypeError(`'exclude' is not a Set.`);\n            }\n            else {\n                return { url, valid: false };\n            }\n        }\n        if (!CrossWindow.isSet(mediaTypes)) {\n            if (throws) {\n                throw new TypeError(`'mediaTypes' is not a Set.`);\n            }\n            else {\n                return { url, valid: false };\n            }\n        }\n        const targetURL = typeof url === 'string' ? URLParser.parse({ url, routePrefix }) : url;\n        if (!targetURL) {\n            if (throws) {\n                throw new TypeError(`'url' is invalid.`);\n            }\n            else {\n                return { url, valid: false };\n            }\n        }\n        const extensionMatch = targetURL.pathname.match(/\\.([a-zA-Z0-9]+)$/);\n        const extension = extensionMatch ? extensionMatch[1].toLowerCase() : void 0;\n        const isExcluded = extension && CrossWindow.isSet(exclude) ? exclude.has(extension) : false;\n        let elementType = void 0;\n        let valid = false;\n        if (extension && !isExcluded) {\n            if (this.#svgExtensions.has(extension) && mediaTypes.has('svg')) {\n                elementType = 'svg';\n                valid = true;\n            }\n            else if (this.#imageExtensions.has(extension) && mediaTypes.has('img')) {\n                elementType = 'img';\n                valid = true;\n            }\n            else if (this.#videoExtensions.has(extension) && mediaTypes.has('video')) {\n                elementType = 'video';\n                valid = true;\n            }\n            else if (this.#audioExtensions.has(extension) && mediaTypes.has('audio')) {\n                elementType = 'audio';\n                valid = true;\n            }\n        }\n        return valid ? {\n            src: url,\n            url: targetURL,\n            extension,\n            elementType,\n            valid\n        } : { url, valid: false };\n    }\n}\nObject.freeze(AssetValidator);\n\n/**\n * Provides utility methods for checking browser capabilities.\n *\n * @see https://kilianvalkhof.com/2021/web/detecting-media-query-support-in-css-and-javascript/\n *\n * @privateRemarks\n * TODO: perhaps add support for various standard media query checks for level 4 & 5.\n */\nclass BrowserSupports {\n    /**\n     * @private\n     */\n    constructor() {\n        throw new Error('BrowserSupports constructor: This is a static class and should not be constructed.');\n    }\n    /**\n     * Check for container query support.\n     *\n     * @returns True if container queries supported.\n     */\n    static get containerQueries() {\n        return 'container' in document.documentElement.style;\n    }\n}\n\n/**\n * Provides access to the Clipboard API for reading / writing text strings. This requires a secure context.\n *\n * Note: `writeText` will attempt to use the older `execCommand` if available when `navigator.clipboard` is not\n * available.\n */\nclass ClipboardAccess {\n    /**\n     * @private\n     */\n    constructor() {\n        throw new Error('ClipboardAccess constructor: This is a static class and should not be constructed.');\n    }\n    /**\n     * Uses `navigator.clipboard` if available to read text from the clipboard.\n     *\n     * Note: Always returns `undefined` when `navigator.clipboard` is not available or the clipboard contains the\n     * empty string.\n     *\n     * @param [activeWindow=window] Optional active current window.\n     *\n     * @returns {Promise<string|undefined>} The current clipboard text or undefined.\n     */\n    static async readText(activeWindow = window) {\n        let result = '';\n        if (!CrossWindow.isWindow(activeWindow)) {\n            throw new TypeError(`ClipboardAccess.readText error: 'activeWindow' is not a Window.`);\n        }\n        if (activeWindow?.navigator?.clipboard) {\n            try {\n                result = await activeWindow.navigator.clipboard.readText();\n            }\n            catch (err) { /**/ }\n        }\n        return result === '' ? void 0 : result;\n    }\n    /**\n     * Uses `navigator.clipboard` if available then falls back to `document.execCommand('copy')` if available to copy\n     * the given text to the clipboard.\n     *\n     * @param text - Text to copy to the browser clipboard.\n     *\n     * @param [activeWindow=window] Optional active current window.\n     *\n     * @returns Copy successful.\n     */\n    static async writeText(text, activeWindow = window) {\n        if (typeof text !== 'string') {\n            throw new TypeError(`ClipboardAccess.writeText error: 'text' is not a string.`);\n        }\n        if (!CrossWindow.isWindow(activeWindow)) {\n            throw new TypeError(`ClipboardAccess.writeText error: 'activeWindow' is not a Window.`);\n        }\n        let success = false;\n        if (activeWindow?.navigator?.clipboard) {\n            try {\n                await activeWindow.navigator.clipboard.writeText(text);\n                success = true;\n            }\n            catch (err) { /**/ }\n        }\n        else if (typeof activeWindow?.document?.execCommand === 'function') {\n            const textArea = activeWindow.document.createElement('textarea');\n            // Place in the top-left corner of the screen regardless of scroll position.\n            textArea.style.position = 'fixed';\n            textArea.style.top = '0';\n            textArea.style.left = '0';\n            // Ensure it has a small width and height. Setting to 1px / 1em\n            // doesn't work as this gives a negative w/h on some browsers.\n            textArea.style.width = '2em';\n            textArea.style.height = '2em';\n            // We don't need padding, reducing the size if it does flash render.\n            textArea.style.padding = '0';\n            // Clean up any borders.\n            textArea.style.border = 'none';\n            textArea.style.outline = 'none';\n            textArea.style.boxShadow = 'none';\n            // Avoid the flash of the white box if rendered for any reason.\n            textArea.style.background = 'transparent';\n            textArea.value = text;\n            activeWindow.document.body.appendChild(textArea);\n            textArea.focus();\n            textArea.select();\n            try {\n                success = activeWindow.document.execCommand('copy');\n            }\n            catch (err) { /**/ }\n            activeWindow.document.body.removeChild(textArea);\n        }\n        return success;\n    }\n}\n\nexport { AssetValidator, BrowserSupports, ClipboardAccess, CrossWindow, URLParser };\n//# sourceMappingURL=index.js.map\n"],
  "mappings": "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",
  "names": []
}
